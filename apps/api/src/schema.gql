# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type ActiveSeasonInfo {
  id: ID!
  name: String!
}

type ActiveSpecialDayInfo {
  id: ID!
  name: String!
  type: SpecialDayType!
}

input AddGroupPlayersInput {
  players: [GroupPlayerInput!]!
}

input AddLineItemInput {
  baseAmount: Float!
  description: String!
  playerId: ID!
  productId: ID
  taxRate: Float
  taxType: TaxType
  type: LineItemType!
  variantId: ID
}

input AddLookupTranslationInput {
  description: String
  locale: String!
  lookupValueId: ID!
  name: String!
}

input AddStoredPaymentInput {
  brand: String!
  cardholderName: String
  expiryMonth: Int
  expiryYear: Int
  isDefault: Boolean = false
  last4: String!
  memberId: String!
  stripeCustomerId: String
  stripePaymentMethodId: String!
}

"""Address type options"""
enum AddressType {
  BILLING
  BOTH
  MAILING
}

type AgingBucketType {
  id: String!
  label: String!
  memberCount: Float!
  percentage: Float!
  totalAmount: String!
}

type AgingMemberType {
  balance: String!
  daysOutstanding: Float!
  id: ID!
  memberNumber: String!
  membershipType: String!
  name: String!
  oldestInvoiceDate: DateTime!
  photoUrl: String
  status: String!
}

"""Days to which a configuration applies"""
enum ApplicableDays {
  ALL
  WEEKDAY
  WEEKEND
}

type ApplicationConnection {
  edges: [ApplicationEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ApplicationEdge {
  cursor: String!
  node: MembershipApplicationType!
}

type ApplicationMembershipTypeType {
  code: String!
  description: String
  id: ID!
  name: String!
}

type ApplicationSponsorType {
  email: String
  firstName: String!
  id: ID!
  lastName: String!
  memberId: String!
  phone: String
}

type ApplicationStatsType {
  approved: Int!
  pendingBoard: Int!
  rejected: Int!
  submitted: Int!
  total: Int!
  underReview: Int!
}

"""Membership application status options"""
enum ApplicationStatus {
  APPROVED
  PENDING_BOARD
  REJECTED
  SUBMITTED
  UNDER_REVIEW
  WITHDRAWN
}

type AppliedDiscountType {
  appliedBy: String!
  approvalNote: String
  approvedBy: String
  calculatedAmount: String!
  createdAt: DateTime!
  discount: DiscountGraphQLType
  discountId: String!
  discountType: DiscountType!
  discountValue: String!
  id: ID!
  lineItemId: String
  transactionId: String
}

input ApplyCreditNoteInput {
  amount: Float!
  invoiceId: ID!
}

input ApplyDiscountByCodeInput {
  code: String!
  lineItemId: ID
  membershipTypeId: ID
  originalAmount: Float!
  playerType: String
  transactionId: ID
}

input ApplyDiscountInput {
  discountId: ID!
  lineItemId: ID
  originalAmount: Float!
  transactionId: ID
}

type ApplyDiscountResultType {
  appliedDiscount: AppliedDiscountType
  discountedAmount: String
  message: String
  originalAmount: String
  requiresApproval: Boolean
  savings: String
  success: Boolean!
}

input ApproveDiscountInput {
  appliedDiscountId: ID!
  approvalNote: String
}

type ArAccountSearchResult {
  accountName: String!
  accountNumber: String!
  accountType: ArAccountType!
  agingStatus: String
  creditBalance: String!
  dependentCount: Float
  id: ID!
  invoiceCount: Float!
  outstandingBalance: String!
  photoUrl: String
  subType: String
}

"""AR account type discriminator"""
enum ArAccountType {
  CITY_LEDGER
  MEMBER
}

type ArAgingReportType {
  buckets: [AgingBucketType!]!
  members: [AgingMemberType!]!
  reinstatedMembers: [ReinstatedMemberType!]!
  totalCount: Float!
}

input AssignEquipmentInput {
  bookingId: ID
  conditionAtCheckout: EquipmentCondition
  equipmentId: ID!
  notes: String
  rentalFee: Float
  teeTimePlayerId: ID
}

input AssignTemplateInput {
  outletId: ID!
  templateId: ID!
}

type AssignTemplateMutationResponse {
  message: String
  outlet: POSOutletGraphQLType
  success: Boolean!
}

type AutoPayAttempt {
  amount: Float!
  attemptNumber: Int!
  clubId: String!
  createdAt: DateTime!
  failedAt: DateTime
  failureCode: String
  failureMessage: String
  id: ID!
  invoiceId: String
  isManualRetry: Boolean!
  memberId: String!
  nextRetryAt: DateTime
  paymentMethod: StoredPaymentMethod
  paymentMethodId: String!
  paymentTransactionId: String
  processedAt: DateTime
  status: AutoPayAttemptStatus!
  stripeChargeId: String
  stripePaymentIntentId: String
  succeededAt: DateTime
  updatedAt: DateTime!
}

"""Status of auto-pay attempt"""
enum AutoPayAttemptStatus {
  CANCELLED
  FAILED
  PENDING
  PROCESSING
  SUCCEEDED
}

type AutoPayResult {
  attemptId: String
  error: String
  message: String
  stripePaymentIntentId: String
  success: Boolean!
}

"""Auto-pay schedule type"""
enum AutoPaySchedule {
  INVOICE_DUE
  MONTHLY_FIXED
  STATEMENT_DATE
}

type AutoPaySetting {
  clubId: String!
  createdAt: DateTime!
  excludeCategories: [String!]!
  id: ID!
  isEnabled: Boolean!
  maxPaymentAmount: Float
  maxRetryAttempts: Int!
  memberId: String!
  monthlyMaxAmount: Float
  notifyBeforePayment: Boolean!
  notifyDaysBefore: Int!
  notifyOnFailure: Boolean!
  notifyOnSuccess: Boolean!
  payDuesOnly: Boolean!
  paymentDayOfMonth: Int
  paymentMethod: StoredPaymentMethod
  paymentMethodId: String!
  requireApprovalAbove: Float
  retryIntervalDays: Int!
  schedule: AutoPaySchedule!
  updatedAt: DateTime!
}

input AutoPaySettingInput {
  excludeCategories: [String!]
  isEnabled: Boolean = true
  maxPaymentAmount: Float
  maxRetryAttempts: Int = 3
  memberId: String!
  monthlyMaxAmount: Float
  notifyBeforePayment: Boolean = true
  notifyDaysBefore: Int = 3
  notifyOnFailure: Boolean = true
  notifyOnSuccess: Boolean = true
  payDuesOnly: Boolean = false
  paymentDayOfMonth: Int
  paymentMethodId: ID!
  requireApprovalAbove: Float
  retryIntervalDays: Int = 3
  schedule: AutoPaySchedule
}

input BatchPaymentInput {
  """For member account charges"""
  chargeToMemberId: ID
  lineItemIds: [ID!]
  paymentMethodId: ID!
  playerIds: [ID!]!
  reference: String
  teeTimeId: ID!
}

type BatchPaymentResultType {
  error: String
  processedSlots: [SlotPaymentResultType!]
  success: Boolean!
  transactionId: String
}

type BatchSettlementAllocation {
  amount: String!
  invoiceId: ID!
  invoiceNumber: String!
  newBalance: String!
  previousBalance: String!
}

input BatchSettlementInput {
  accountId: ID!
  accountType: ArAccountType!
  method: PaymentMethod!
  notes: String
  paymentAmount: Float!
  paymentDate: DateTime
  referenceNumber: String
  useFifo: Boolean = true
}

type BatchSettlementResult {
  allocations: [BatchSettlementAllocation!]!
  creditAdded: String!
  newCreditBalance: String!
  newOutstandingBalance: String!
  paymentId: ID!
  receiptNumber: String!
  totalAllocated: String!
}

type BatchTotalType {
  balanceDue: Float!
  grandTotal: Float!
  lineItemCount: Int!
  paidAmount: Float!
  playerIds: [ID!]!
  subtotal: Float!
  taxTotal: Float!
}

"""Billing frequency options"""
enum BillingFrequency {
  ANNUAL
  MONTHLY
  QUARTERLY
  SEMI_ANNUAL
}

"""Preview of an upcoming billing period"""
type BillingPeriodPreview {
  """Date when the invoice will be generated/billed"""
  billingDate: DateTime!

  """Human-readable description of the period"""
  description: String!

  """Due date for payment"""
  dueDate: DateTime!

  """End date of the billing period"""
  periodEnd: DateTime!

  """Start date of the billing period"""
  periodStart: DateTime!
}

type BillingStatsType {
  invoiceCount: Float!
  outstandingBalance: String!
  overdueAmount: String!
  overdueCount: Float!
  paidCount: Float!
  totalRevenue: String!
}

"""Billing timing options (advance or arrears)"""
enum BillingTiming {
  ADVANCE
  ARREARS
}

type BlockMutationResponse {
  block: TeeTimeBlockType
  message: String
  success: Boolean!
}

"""Type of tee time block"""
enum BlockType {
  MAINTENANCE
  PRIVATE
  STARTER
  TOURNAMENT
  WEATHER
}

type BookingConnection {
  edges: [BookingEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type BookingEdge {
  cursor: String!
  node: BookingType!
}

type BookingGroupBookedByType {
  id: ID!
  memberId: String
  name: String!
}

type BookingGroupType {
  bookedBy: BookingGroupBookedByType!
  groupNumber: Int!
  id: ID!
  playerIds: [String!]!
}

type BookingLineItemType {
  baseAmount: Float!
  description: String!
  id: ID!
  isPaid: Boolean!
  paidAt: DateTime
  paymentMethod: String
  productId: ID
  reference: String
  taxAmount: Float!
  taxRate: Float!
  taxType: TaxType!
  totalAmount: Float!
  type: LineItemType!
  variantId: ID
}

type BookingMemberType {
  firstName: String!
  id: ID!
  lastName: String!
  memberId: String!
  photoUrl: String
  status: String!
}

"""
Tee sheet display mode - EIGHTEEN (single column) or CROSS (dual columns)
"""
enum BookingMode {
  CROSS
  EIGHTEEN
}

type BookingPricingType {
  basePrice: Float!
  modifiers: [PriceModifierType!]!
  subtotal: Float!
  tax: Float
  total: Float!
}

type BookingStatsType {
  checkedInBookings: Int!
  completedBookings: Int!
  confirmedBookings: Int!
  noShows: Int!
  todayBookings: Int!
  utilizationRate: Float!
}

enum BookingStatus {
  CANCELLED
  CHECKED_IN
  COMPLETED
  CONFIRMED
  IN_PROGRESS
  NO_SHOW
  PENDING
}

type BookingType {
  bookingNumber: String!
  bookingType: BookingTypeEnum!
  bufferAfter: Int
  bufferBefore: Int
  cancelReason: String
  cancelledAt: DateTime
  checkedInAt: DateTime
  createdAt: DateTime!
  createdBy: String
  durationMinutes: Int!
  endTime: DateTime!
  facility: FacilityType
  guestCount: Int
  id: ID!
  member: BookingMemberType!
  notes: String
  pricing: BookingPricingType
  resource: ResourceType
  service: ServiceType
  staff: StaffType
  startTime: DateTime!
  status: BookingStatus!
}

enum BookingTypeEnum {
  FACILITY
  SERVICE
}

input BulkOutletProductConfigInput {
  categoryId: ID
  isQuickKey: Boolean
  isVisible: Boolean
  productIds: [ID!]!
}

input BulkRemoveLineItemsInput {
  lineItemIds: [ID!]!
}

type BulkRemoveResultType {
  error: String
  removedCount: Int!
  removedItems: [SlotLineItemType!]!
  success: Boolean!
}

input BulkTransferLineItemsInput {
  lineItemIds: [ID!]!
  toPlayerId: ID!
}

type BulkTransferResultType {
  error: String
  success: Boolean!
  transferredCount: Int!
}

input BulkUpdateProShopProductInput {
  categoryId: ID
  isActive: Boolean
  isQuickAdd: Boolean
}

input CSVPlayerRow {
  email: String
  handicap: Int
  memberId: String
  name: String!
  phone: String
}

type CaddyRateMutationResponse {
  caddyRate: CaddyRateType
  message: String
  success: Boolean!
}

type CaddyRateType {
  amount: Float!
  caddyType: String!
  createdAt: DateTime!
  id: ID!
  taxRate: Float!
  taxType: String!
  updatedAt: DateTime!
}

type CaddyType {
  caddyNumber: String!
  firstName: String!
  id: ID!
  isActive: Boolean!
  lastName: String!
  phone: String
}

type CalendarBookingType {
  bookingNumber: String!
  bufferAfter: Int
  bufferBefore: Int
  endTime: DateTime!
  id: ID!
  memberName: String!
  memberPhotoUrl: String
  resourceId: ID!
  serviceName: String!
  startTime: DateTime!
  status: BookingStatus!
}

type CalendarDayType {
  bookings: [CalendarBookingType!]!
  date: DateTime!
  resources: [CalendarResourceType!]!
}

type CalendarResourceType {
  id: ID!
  name: String!
  subtitle: String
  type: ResourceTypeEnum!
}

input CancelBookingInput {
  id: ID!
  reason: String!
}

type CancelBookingResponseType {
  error: String
  message: String
  success: Boolean!
}

type CancelResponseType {
  message: String!
}

type CartDraftType {
  createdBy: String!

  """JSON stringified draft data"""
  draftData: String!
  id: ID!
  teeTimeId: ID!
  updatedAt: DateTime!
}

"""Cart policy for golf bookings"""
enum CartPolicy {
  OPTIONAL
  REQUIRED
}

type CartRateMutationResponse {
  cartRate: CartRateType
  message: String
  success: Boolean!
}

type CartRateType {
  amount: Float!
  cartType: String!
  createdAt: DateTime!
  id: ID!
  taxRate: Float!
  taxType: String!
  updatedAt: DateTime!
}

"""Golf cart type"""
enum CartType {
  SHARED
  SINGLE
  WALKING
}

type CashDrawerGraphQLType {
  clubId: ID!
  createdAt: DateTime!
  currentShift: CashDrawerShiftGraphQLType
  id: ID!
  isActive: Boolean!
  location: String
  name: String!
  updatedAt: DateTime!
}

type CashDrawerShiftGraphQLType {
  actualCash: Float
  cashDrawerId: ID!
  closedAt: DateTime
  closedBy: ID
  closingCount: Float

  """JSON string of denomination counts"""
  closingDenominations: String
  createdAt: DateTime!
  expectedCash: Float
  id: ID!
  movements: [CashMovementGraphQLType!]
  openedAt: DateTime!
  openedBy: ID!

  """JSON string of denomination counts"""
  openingDenominations: String
  openingFloat: Float!
  status: CashDrawerStatus!
  totalDrops: Float!
  totalPaidIn: Float!
  totalPaidOut: Float!
  totalRefunds: Float!
  totalSales: Float!
  variance: Float
  varianceNote: String
}

"""Status of a cash drawer shift"""
enum CashDrawerStatus {
  CLOSED
  OPEN
  SUSPENDED
}

type CashMovementGraphQLType {
  amount: Float!
  approvedBy: ID
  description: String
  id: ID!
  performedAt: DateTime!
  performedBy: ID!
  reason: String
  reference: String
  shiftId: ID!
  transactionId: ID
  type: CashMovementType!
}

"""Type of cash movement"""
enum CashMovementType {
  ADJUSTMENT
  CASH_REFUND
  CASH_SALE
  CLOSING_COUNT
  DROP
  OPENING_FLOAT
  PAID_IN
  PAID_OUT
}

enum CategoryDisplayStyle {
  DROPDOWN
  SIDEBAR
  TABS
}

input ChangeApplicationStatusInput {
  rejectionReason: String
  reviewNotes: String
  status: ApplicationStatus!
}

input ChangePinInput {
  newPin: String!
  subAccountId: String!
}

input ChangeStatusInput {
  reason: String
  status: MemberStatus!
}

input ChangeSubAccountStatusInput {
  status: SubAccountStatus!
  subAccountId: String!
}

type ChargeTypeType {
  category: String
  code: String!
  defaultPrice: String
  description: String
  id: ID!
  name: String!
  taxable: Boolean!
}

input CheckCreditInput {
  chargeAmount: Float!
  memberId: ID!
}

input CheckInAllPlayersInput {
  cartNumber: String
  notes: String
  skipPaymentValidation: Boolean = false
  teeTimeId: ID!
}

type CheckInAuditEntryType {
  action: String!
  amount: Float
  details: String
  id: ID!
  performedAt: DateTime!
  performedBy: String!
  playerId: ID
  playerName: String
  teeTimeId: ID!
}

input CheckInFlightInput {
  cartNumber: String
  generateTicket: Boolean = true
  notes: String
  players: [CheckInPlayerInput!]!
  teeTimeId: ID!
}

input CheckInHistoryFilterInput {
  action: String
  endDate: DateTime
  limit: Float = 50
  playerId: ID
  startDate: DateTime
  teeTimeId: ID
}

input CheckInInput {
  bookingId: ID!
  outletId: ID
}

type CheckInPaymentMethodType {
  icon: String!
  id: ID!
  isEnabled: Boolean!
  name: String!
  opensPOS: Boolean!
  requiresRef: Boolean!
  sortOrder: Int!
  type: PaymentMethodTypeEnum!
}

type CheckInPlayerInfoType {
  balanceDue: Float!
  checkedInAt: DateTime
  id: ID!
  isCheckedIn: Boolean!
  isSuspended: Boolean!
  lineItems: [BookingLineItemType!]!
  memberNumber: String
  name: String!
  paymentStatus: PaymentStatus!
  suspensionReason: String
  totalDue: Float!
  totalPaid: Float!
  type: CheckInPlayerType!
}

input CheckInPlayerInput {
  playerId: ID!
  skipPaymentValidation: Boolean = false
}

"""Player type for check-in (more granular than PlayerType)"""
enum CheckInPlayerType {
  DEPENDENT
  GUEST
  MEMBER
  WALKUP
}

input CheckInPolicyInput {
  allowPartialPayment: Boolean
  blockSuspendedMembers: Boolean
  requireAllItemsPaid: Boolean
  showSuspensionReason: Boolean
}

type CheckInPolicyType {
  allowPartialPayment: Boolean!
  blockSuspendedMembers: Boolean!
  requireAllItemsPaid: Boolean!
  showSuspensionReason: Boolean!
}

type CheckInResponseType {
  booking: BookingType
  checkedInAt: DateTime!
  error: String
  success: Boolean!
}

type CheckInResultType {
  checkedInAt: DateTime!
  checkedInBy: String!
  players: [PlayerCheckInResultType!]!
  success: Boolean!
  ticketId: ID
  ticketNumber: String
}

type CheckInSettingsType {
  paymentMethods: [CheckInPaymentMethodType!]!
  policy: CheckInPolicyType!
  pos: POSConfigType!
  proShop: ProShopConfigType!
  starterTicket: StarterTicketConfigType!
  tax: TaxConfigType!
}

input CheckInSlotsInput {
  notes: String
  playerIds: [ID!]!
  teeTimeId: ID!
}

type CheckInSlotsResultType {
  checkedInSlots: [SlotCheckInResultType!]
  error: String
  success: Boolean!
  ticketId: ID
  ticketNumber: String
}

input CheckLimitInput {
  amount: Float!
  category: SubAccountPermission!
  subAccountId: String!
}

"""City ledger account type"""
enum CityLedgerAccountType {
  CORPORATE
  HOUSE_ACCOUNT
  OTHER
  VENDOR
}

"""City ledger account status"""
enum CityLedgerStatus {
  ACTIVE
  CLOSED
  INACTIVE
  SUSPENDED
}

type CityLedgerType {
  accountName: String!
  accountNumber: String!
  accountType: CityLedgerAccountType!
  billingAddress: String
  contactEmail: String
  contactName: String
  contactPhone: String
  createdAt: DateTime!
  creditBalance: String!
  creditLimit: String
  id: ID!
  notes: String
  outstandingBalance: String!
  paymentTerms: Float!
  status: CityLedgerStatus!
  taxId: String
  updatedAt: DateTime!
}

type CityLedgerTypeEdge {
  cursor: String!
  node: CityLedgerType!
}

type CloneTemplateMutationResponse {
  message: String
  success: Boolean!
  template: POSTemplateGraphQLType
}

input ClosePeriodInput {
  periodEnd: DateTime!
}

input CloseSettlementInput {
  notes: String
  settlementId: ID!
}

input CloseShiftInput {
  closingCount: Float!

  """JSON string of denomination counts"""
  denominations: String
  shiftId: ID!
  varianceNote: String
}

"""Club billing configuration settings"""
type ClubBillingSettingsType {
  """Whether to automatically apply late fees when due"""
  autoApplyLateFee: Boolean!
  clubId: ID!

  """When the settings were created"""
  createdAt: DateTime!

  """Billing cycle alignment (calendar or anniversary)"""
  defaultAlignment: CycleAlignment!

  """Default day of month for billing (1-28)"""
  defaultBillingDay: Int!

  """Default billing frequency for new members"""
  defaultFrequency: BillingFrequency!

  """Whether to bill in advance or arrears"""
  defaultTiming: BillingTiming!

  """Grace period days after due date before late fees"""
  gracePeriodDays: Int!
  id: ID!

  """Days after invoice date when payment is due"""
  invoiceDueDays: Int!

  """Days before billing cycle to generate invoices"""
  invoiceGenerationLead: Int!

  """Fixed late fee amount (in cents)"""
  lateFeeAmount: Float!

  """Late fee percentage (0-100)"""
  lateFeePercentage: Float!

  """Type of late fee to apply"""
  lateFeeType: LateFeeType!

  """Maximum late fee cap amount (in cents)"""
  maxLateFee: Float

  """Whether to prorate charges for membership changes mid-cycle"""
  prorateChanges: Boolean!

  """Whether to prorate charges for new members mid-cycle"""
  prorateNewMembers: Boolean!

  """Method used for calculating prorated amounts"""
  prorationMethod: ProrationMethod!

  """When the settings were last updated"""
  updatedAt: DateTime!
}

type ClubGolfSettingsType {
  caddyDrivesCart: Boolean!
  cartPolicy: CartPolicy!
  id: ID!
  maxGuestsPerMember: Int!
  rentalPolicy: RentalPolicy!
  requireGuestContact: Boolean!
}

input CourseIntervalInput {
  dayType: DayType!
  intervalMin: Int! = 8
  isPrimeTime: Boolean! = false
  timeEnd: String!
  timeStart: String!
}

input CreateAddressInput {
  addressLine1: String!
  addressLine2: String
  country: String = "Thailand"
  district: String!
  isPrimary: Boolean = false
  label: String
  memberId: ID!
  postalCode: String!
  province: String!
  subDistrict: String!
  type: AddressType = BILLING
}

input CreateApplicationInput {
  email: String!
  firstName: String!
  lastName: String!
  membershipTypeId: ID!
  phone: String
  reviewNotes: String
  sponsorId: ID
}

input CreateBlockInput {
  blockType: BlockType!
  courseId: ID!
  endTime: DateTime!
  isRecurring: Boolean! = false
  reason: String
  recurringPattern: String
  startTime: DateTime!
}

input CreateBookingInput {
  addOnIds: [String!]
  bookingType: BookingTypeEnum!
  endTime: String!
  facilityId: ID
  guestCount: Int
  memberId: ID!
  notes: String
  resourceId: ID
  serviceId: ID
  staffId: ID
  startTime: String!
}

type CreateBookingResponseType {
  booking: BookingType
  error: String
  success: Boolean!
}

input CreateCaddyRateInput {
  amount: Float!
  caddyType: String!
  rateConfigId: ID!
  taxRate: Float! = 0
  taxType: String! = "NONE"
}

input CreateCartRateInput {
  amount: Float!
  cartType: String!
  rateConfigId: ID!
  taxRate: Float! = 0
  taxType: String! = "ADD"
}

input CreateCashDrawerInput {
  location: String
  name: String!
}

input CreateCreditNoteInput {
  internalNotes: String
  lineItems: [CreditNoteLineItemInput!]!
  memberId: ID!
  memberVisibleNotes: String
  reason: CreditNoteReason!
  reasonDetail: String
  sourceInvoiceId: ID
  type: CreditNoteType!
}

input CreateCreditOverrideInput {
  expiresAt: DateTime
  memberId: ID!
  newLimit: Float!
  reason: String!
}

input CreateDependentInput {
  dateOfBirth: DateTime
  email: String
  firstName: String!
  lastName: String!
  memberId: ID!
  phone: String
  relationship: String!
}

input CreateDiscountInput {
  approval: DiscountApprovalInput
  code: String
  conditions: DiscountConditionsInput
  isActive: Boolean! = true
  name: String!
  scope: DiscountScope!
  type: DiscountType!
  validity: DiscountValidityInput
  value: Float!
}

input CreateEquipmentCategoryInput {
  attachmentType: EquipmentAttachmentType
  code: String!
  color: String
  defaultRentalRate: Float
  depositAmount: Float
  description: String
  icon: String
  name: String!
  operationType: OperationType = FACILITY
  requiresDeposit: Boolean
}

input CreateEquipmentInput {
  assetNumber: String!
  categoryId: ID!
  condition: EquipmentCondition
  location: String
  manufacturer: String
  model: String
  name: String!
  notes: String
  purchaseDate: DateTime
  serialNumber: String
  warrantyExpiry: DateTime
}

input CreateExceptionInput {
  amount: Float
  description: String!
  lineItemId: ID
  settlementId: ID!
  severity: ExceptionSeverity
  shiftId: ID
  transactionId: ID
  type: ExceptionType!
}

input CreateFacilityInput {
  capacity: Int!
  description: String
  features: [String!]
  isActive: Boolean = true
  location: String!
  name: String!
  operatingHours: [DayHoursInput!]
  outletId: ID
  revenueCenterId: ID
  type: ResourceTypeEnum!
}

input CreateGreenFeeRateInput {
  amount: Float!
  holes: Int!
  playerType: String!
  rateConfigId: ID!
  taxRate: Float! = 0
  taxType: String! = "ADD"
  timeCategory: String! = "STANDARD"
}

input CreateGroupBookingInput {
  courseId: ID!
  eventDate: DateTime!
  groupName: String!
  notes: String
  players: [GroupPlayerInput!]
  startFormat: StartFormat! = SEQUENTIAL
  startTime: String!
}

"""Input for creating an interest category"""
input CreateInterestCategoryInput {
  code: String!
  color: String
  description: String
  icon: String
  isActive: Boolean = true
  name: String!
  sortOrder: Int = 0
}

input CreateInvoiceInput {
  billingPeriod: String
  dueDate: DateTime!
  internalNotes: String
  invoiceDate: DateTime!
  lineItems: [InvoiceLineItemInput!]!
  memberId: ID!
  notes: String
  sendEmail: Boolean = false
}

input CreateLookupValueInput {
  categoryId: ID!
  code: String!
  color: String
  description: String
  icon: String
  isActive: Boolean
  isDefault: Boolean
  metadata: JSON
  name: String!
  sortOrder: Int
}

input CreateLotteryInput {
  courseId: ID!
  drawTime: DateTime!
  lotteryDate: DateTime!
  lotteryType: LotteryType! = PRIME_TIME
  maxRequestsPerMember: Int! = 1
  requestWindowEnd: DateTime!
  requestWindowStart: DateTime!
  timeRangeEnd: String!
  timeRangeStart: String!
}

input CreateLotteryRequestInput {
  lotteryId: ID!
  playerCount: Int! = 1
  preference1: String!
  preference2: String
  preference3: String
}

input CreateMemberBillingProfileInput {
  billingAlignment: CycleAlignment
  billingFrequency: BillingFrequency
  billingTiming: BillingTiming

  """Custom billing day (1-28)"""
  customBillingDay: Int

  """Custom grace period in days"""
  customGracePeriod: Int

  """Exempt from late fees"""
  customLateFeeExempt: Boolean
  memberId: ID!

  """Next scheduled billing date"""
  nextBillingDate: DateTime
  prorationOverride: ProrationMethod
}

input CreateMemberInput {
  address: String
  dateOfBirth: DateTime
  email: String
  emergencyContact: String
  emergencyPhone: String
  expiryDate: DateTime
  firstName: String!
  gender: String
  householdId: ID
  idNumber: String
  isPrimaryMember: Boolean
  joinDate: DateTime
  lastName: String!
  membershipTierId: ID
  membershipTypeId: ID!
  nationality: String
  notes: String
  phone: String
  referralSource: String
  referredById: ID
  status: MemberStatus
  tags: [String!]
}

input CreateModifierGroupInput {
  maxSelections: Int
  minSelections: Int
  modifiers: [CreateModifierInput!]
  name: String!
  selectionType: ModifierSelectionType
}

input CreateModifierInput {
  isDefault: Boolean
  name: String!
  priceAdjustment: Float
  sortOrder: Int
}

input CreatePaymentInput {
  accountLast4: String
  allocations: [PaymentAllocationInput!]
  amount: Float!
  bankName: String
  memberId: ID!
  method: PaymentMethod!
  notes: String
  paymentDate: DateTime
  referenceNumber: String
}

input CreatePaymentMethodInput {
  icon: String!
  name: String!
  opensPOS: Boolean = false
  requiresRef: Boolean = false
  type: PaymentMethodTypeEnum!
}

input CreateProShopCategoryInput {
  defaultTaxRate: Float!
  defaultTaxType: TaxType!
  description: String
  isActive: Boolean = true
  name: String!
}

input CreateProShopProductInput {
  categoryId: ID!
  description: String
  isActive: Boolean = true
  isQuickAdd: Boolean = false
  name: String!
  price: Float!
  sku: String
  taxRate: Float
  taxType: TaxType
  useCategoryDefaults: Boolean = true
  variants: [CreateProShopVariantInput!]
}

input CreateProShopVariantInput {
  name: String!
  priceAdjustment: Float = 0
  sku: String
}

input CreateProductCategoryInput {
  color: String
  description: String
  iconName: String
  name: String!
  parentId: ID
  sortOrder: Int
}

input CreateProductInput {
  basePrice: Float!
  bufferMinutes: Int
  categoryId: ID!
  costPrice: Float
  description: String
  durationMinutes: Int
  imageUrl: String
  lowStockThreshold: Int
  modifierGroupIds: [ID!]
  name: String!
  productType: ProductType
  requiredCapabilities: [String!]
  sku: String
  sortPriority: Int
  stockQuantity: Int
  taxRate: Float
  thumbnailUrl: String
  trackInventory: Boolean
  variants: [CreateProductVariantInput!]
}

input CreateProductVariantInput {
  attributes: JSON
  imageUrl: String
  name: String!
  priceAdjustment: Float
  sku: String
  sortOrder: Int
  stockQuantity: Int
}

input CreateRateConfigInput {
  courseId: ID!
  description: String
  effectiveFrom: DateTime!
  effectiveTo: DateTime
  name: String!
}

input CreateRequirementInput {
  allowPartialCredit: Boolean = false
  defaultShortfallAction: ShortfallAction
  description: String
  effectiveFrom: DateTime
  effectiveTo: DateTime
  excludedCategories: [String!]
  gracePeriodDays: Int = 0
  includeEvents: Boolean = false
  includeFoodBeverage: Boolean = true
  includeGolf: Boolean = true
  includeRetail: Boolean = false
  includeSpa: Boolean = false
  includedCategories: [String!]
  membershipTypes: [String!]!
  minimumAmount: Float!
  name: String!
  notifyAtPercent: [Int!]
  notifyDaysBeforeEnd: [Int!]
  period: MinimumSpendPeriod!
}

input CreateScheduleInput {
  courseId: ID!
  endDate: DateTime!
  firstTeeTime: String!
  intervals: [CourseIntervalInput!]
  lastTeeTime: String!
  paceOfPlay: Int
  playFormat: PlayFormat! = EIGHTEEN_HOLE
  seasonName: String!
  startDate: DateTime!
}

input CreateSeasonInput {
  endDay: Int!
  endMonth: Int!
  isRecurring: Boolean = true
  name: String!
  overrideBookingWindow: Int
  overrideFirstTee: String
  overrideLastTee: String
  overrideTimePeriods: Boolean = false
  overrideTwilightTime: String
  priority: Int = 0
  startDay: Int!
  startMonth: Int!
  weekdayBookingMode: BookingMode
  weekendBookingMode: BookingMode
}

input CreateServiceInput {
  basePrice: Float!
  bufferMinutes: Int = 0
  category: String!
  description: String
  durationMinutes: Int!
  isActive: Boolean = true
  maxParticipants: Int
  name: String!
  requiredCapabilities: [String!]
  requiredFacilityFeatures: [String!]
  revenueCenterId: ID
  tierDiscounts: [TierDiscountInput!]
  variations: [ServiceVariationInput!]
}

input CreateSpecialDayInput {
  bookingMode: BookingMode
  customFirstTee: String
  customLastTee: String
  customTimePeriods: Boolean = false
  endDate: String!
  isRecurring: Boolean = true
  name: String!
  notes: String
  startDate: String!
  type: SpecialDayType!
}

input CreateStaffMemberInput {
  avatarUrl: String
  capabilities: [StaffCapabilityInput!]
  certifications: [StaffCertificationInput!]
  defaultFacilityId: ID
  email: String
  firstName: String!
  isActive: Boolean = true
  lastName: String!
  phone: String
  userId: ID
  workingHours: [DayHoursInput!]
}

input CreateSubAccountInput {
  dailyLimit: Float
  email: String
  memberId: String!
  monthlyLimit: Float
  name: String!
  notifyOnLimitReached: Boolean = true
  notifyPrimaryOnUse: Boolean = false
  perTransactionLimit: Float
  permissions: [SubAccountPermission!]
  phone: String
  pin: String!
  relationship: String!
  validFrom: DateTime
  validUntil: DateTime
  weeklyLimit: Float
}

input CreateTeeTimeInput {
  courseId: ID!
  holes: Int = 18
  notes: String
  players: [TeeTimePlayerInput!]!
  startingHole: Int = 1
  teeDate: DateTime!
  teeTime: String!
}

input CreateTimePeriodInput {
  applicableDays: ApplicableDays!
  endTime: String
  intervalMinutes: Int!
  isPrimeTime: Boolean!
  name: String!
  sortOrder: Int
  startTime: String!
}

input CreateWaitlistEntryInput {
  courseId: ID!
  playerCount: Int! = 1
  requestedDate: DateTime!
  requesterEmail: String
  requesterName: String!
  requesterPhone: String!
  timeRangeEnd: String!
  timeRangeStart: String!
}

type CreditCheckResultType {
  allowed: Boolean!
  availableCredit: Float!
  chargeAmount: Float!
  creditLimit: Float!
  currentBalance: Float!
  newBalance: Float!
  shortfall: Float
  usagePercent: Float!
  warning: CreditWarningLevel
}

type CreditLimitOverrideType {
  approvedAt: DateTime!
  approvedBy: ID!
  createdAt: DateTime!
  expiresAt: DateTime
  id: ID!
  isActive: Boolean!
  memberId: ID!
  newLimit: Float!
  previousLimit: Float!
  reason: String!
}

type CreditNoteApplicationType {
  amountApplied: String!
  appliedAt: DateTime!
  id: ID!
  invoice: InvoiceType
}

type CreditNoteConnection {
  edges: [CreditNoteGraphQLTypeEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type CreditNoteGraphQLType {
  applications: [CreditNoteApplicationType!]
  appliedToBalance: String!
  approvedAt: DateTime
  createdAt: DateTime!
  creditNoteNumber: String!
  id: ID!
  internalNotes: String
  issueDate: DateTime!
  lineItems: [CreditNoteLineItemType!]!
  member: MemberSummaryBillingType
  memberVisibleNotes: String
  reason: CreditNoteReason!
  reasonDetail: String
  refundedAmount: String!
  status: CreditNoteStatus!
  subtotal: String!
  taxAmount: String!
  totalAmount: String!
  type: CreditNoteType!
  updatedAt: DateTime!
  voidedAt: DateTime
}

type CreditNoteGraphQLTypeEdge {
  cursor: String!
  node: CreditNoteGraphQLType!
}

input CreditNoteLineItemInput {
  chargeTypeId: ID
  description: String!
  quantity: Float! = 1
  taxRate: Float = 0
  taxable: Boolean = false
  unitPrice: Float!
}

type CreditNoteLineItemType {
  chargeType: ChargeTypeType
  description: String!
  id: ID!
  lineTotal: String!
  quantity: Float!
  taxAmount: String!
  taxRate: String!
  taxable: Boolean!
  unitPrice: String!
}

"""Credit note reason options"""
enum CreditNoteReason {
  BILLING_ERROR
  CUSTOMER_SATISFACTION
  DUPLICATE_CHARGE
  EVENT_CANCELLATION
  MEMBERSHIP_CANCELLATION
  OTHER
  OVERPAYMENT
  PRICE_ADJUSTMENT
  PRODUCT_RETURN
  RAIN_CHECK
  SERVICE_NOT_RENDERED
}

"""Credit note status options"""
enum CreditNoteStatus {
  APPLIED
  APPROVED
  DRAFT
  PARTIALLY_APPLIED
  PENDING_APPROVAL
  REFUNDED
  VOIDED
}

"""Credit note type options"""
enum CreditNoteType {
  ADJUSTMENT
  CANCELLATION
  COURTESY
  PROMO
  REFUND
  RETURN
  WRITE_OFF
}

type CreditSettingsType {
  creditAlertThreshold: Float!
  creditBlockEnabled: Boolean!
  creditLimit: Float
  creditLimitEnabled: Boolean!
  creditOverrideAllowed: Boolean!
}

type CreditStatusType {
  alertThreshold: Float!
  availableCredit: Float!
  creditLimit: Float!
  currentBalance: Float!
  isBlocked: Boolean!
  overrideAllowed: Boolean!
  usagePercent: Float!
}

"""Warning level for credit limit status"""
enum CreditWarningLevel {
  APPROACHING_LIMIT
  EXCEEDED
}

"""Billing cycle alignment (calendar or anniversary)"""
enum CycleAlignment {
  ANNIVERSARY
  CALENDAR
}

type DailyCheckInReportType {
  checkedInPlayers: Int!
  course: String!
  date: DateTime!
  flights: [FlightPaymentSummaryType!]!
  noShowPlayers: Int!
  totalAccount: Float!
  totalCard: Float!
  totalCash: Float!
  totalFlights: Int!
  totalPlayers: Int!
  totalRevenue: Float!
  totalTransfer: Float!
}

input DailyReportInput {
  courseId: ID!
  date: DateTime!
}

type DailySettlementGraphQLType {
  actualCash: Float
  businessDate: DateTime!
  cashVariance: Float
  closedAt: DateTime
  closedBy: ID
  clubId: ID!
  createdAt: DateTime!
  exceptions: [SettlementExceptionGraphQLType!]
  expectedCash: Float!
  id: ID!
  notes: String
  openedAt: DateTime
  openedBy: ID
  refundCount: Int!
  reviewedAt: DateTime
  reviewedBy: ID
  status: SettlementStatus!
  totalCard: Float!
  totalCash: Float!
  totalDiscounts: Float!
  totalGrossSales: Float!
  totalMemberAccount: Float!
  totalNetSales: Float!
  totalOther: Float!
  totalRefunds: Float!
  totalServiceCharge: Float!
  totalTax: Float!
  totalVoids: Float!
  transactionCount: Int!
  updatedAt: DateTime!
  voidCount: Int!
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

input DayHoursInput {
  closeTime: String
  dayOfWeek: String!
  isOpen: Boolean!
  openTime: String
}

type DayHoursType {
  closeTime: String
  dayOfWeek: String!
  isOpen: Boolean!
  openTime: String
}

"""Day type for scheduling"""
enum DayType {
  HOLIDAY
  WEEKDAY
  WEEKEND
}

type DeleteAddressResponseType {
  success: Boolean!
}

type DeleteDependentResponseType {
  message: String!
}

type DeleteMemberResponseType {
  message: String!
}

type DeleteMutationResponse {
  message: String
  success: Boolean!
}

type DeleteRateMutationResponse {
  message: String
  success: Boolean!
}

type DeleteResponseType {
  error: String
  message: String
  success: Boolean!
}

type DeleteTemplateMutationResponse {
  message: String
  success: Boolean!
}

"""Single interest entry for a dependent"""
input DependentInterestInput {
  categoryId: ID!
  interestLevel: Int!
}

"""Dependent interest in an activity category"""
type DependentInterestType {
  category: InterestCategoryType
  categoryId: ID!
  createdAt: DateTime!
  dependentId: ID!
  id: ID!

  """Interest level 0-100"""
  interestLevel: Int!
  updatedAt: DateTime!
}

type DependentType {
  dateOfBirth: DateTime
  email: String
  firstName: String!
  id: ID!
  isActive: Boolean!
  lastName: String!
  phone: String
  relationship: String!
}

input DiscountApprovalInput {
  approvalThreshold: Float
  requiresApproval: Boolean! = false
}

type DiscountApprovalType {
  approvalThreshold: String
  requiresApproval: Boolean!
}

input DiscountConditionsInput {
  maximumDiscount: Float
  membershipTypeIds: [ID!]
  minimumAmount: Float
  playerTypes: [String!]
}

type DiscountConditionsType {
  maximumDiscount: String
  membershipTypeIds: [String!]
  minimumAmount: String
  playerTypes: [String!]
}

type DiscountConnection {
  edges: [DiscountGraphQLTypeEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type DiscountGraphQLType {
  approval: DiscountApprovalType!
  clubId: String!
  code: String
  conditions: DiscountConditionsType!
  createdAt: DateTime!
  id: ID!
  isActive: Boolean!
  name: String!
  scope: DiscountScope!
  type: DiscountType!
  updatedAt: DateTime!
  validity: DiscountValidityType!
  value: String!
}

type DiscountGraphQLTypeEdge {
  cursor: String!
  node: DiscountGraphQLType!
}

"""Scope of discount application"""
enum DiscountScope {
  LINE_ITEM
  ORDER
}

"""Type of discount calculation"""
enum DiscountType {
  FIXED_AMOUNT
  PERCENTAGE
}

type DiscountValidationResultType {
  calculatedAmount: String
  isValid: Boolean!
  message: String
  requiresApproval: Boolean
}

input DiscountValidityInput {
  usageLimit: Float
  validFrom: DateTime
  validTo: DateTime
}

type DiscountValidityType {
  usageCount: Float!
  usageLimit: Float
  validFrom: DateTime
  validTo: DateTime
}

type EffectiveScheduleType {
  activeSeason: ActiveSeasonInfo
  activeSpecialDay: ActiveSpecialDayInfo
  bookingMode: BookingMode!
  bookingWindowDays: Int!
  courseId: ID!
  date: String!
  firstTee: String!
  isClosed: Boolean!
  lastTee: String!
  timePeriods: [GolfTimePeriodType!]!
  twilightMode: TwilightMode!
  twilightTime: String!
}

"""Response for engagement delete operations"""
type EngagementDeleteResponse {
  message: String!
}

"""Individual equipment item"""
type Equipment {
  assetNumber: String!
  category: EquipmentCategory!
  condition: EquipmentCondition!
  currentAssignment: EquipmentAssignment
  id: ID!
  lastMaintenanceAt: DateTime
  location: String
  manufacturer: String
  model: String
  name: String!
  nextMaintenanceAt: DateTime
  notes: String
  purchaseDate: DateTime
  serialNumber: String
  status: EquipmentStatus!
  warrantyExpiry: DateTime
}

"""Equipment assignment to a booking or tee time player"""
type EquipmentAssignment {
  assignedAt: DateTime!
  bookingNumber: String
  conditionAtCheckout: EquipmentCondition
  conditionAtReturn: EquipmentCondition
  id: ID!
  member: EquipmentAssignmentMember
  notes: String
  rentalFee: Float
  returnedAt: DateTime
}

"""Member info for equipment assignment"""
type EquipmentAssignmentMember {
  avatarUrl: String
  firstName: String!
  id: ID!
  lastName: String!
  memberId: String!
}

type EquipmentAssignmentResponse {
  assignment: EquipmentAssignment
  error: String
  success: Boolean!
}

"""Type of equipment attachment to bookings"""
enum EquipmentAttachmentType {
  OPTIONAL_ADDON
  REQUIRED_RESOURCE
}

input EquipmentAvailabilityInput {
  categoryId: ID!
  endTime: DateTime!
  startTime: DateTime!
}

"""Equipment category for grouping similar equipment types"""
type EquipmentCategory {
  attachmentType: EquipmentAttachmentType!
  availableCount: Int!
  code: String!
  color: String
  defaultRentalRate: Float
  depositAmount: Float
  description: String
  equipmentCount: Int!
  icon: String
  id: ID!
  isActive: Boolean!
  name: String!
  operationType: OperationType!
  requiresDeposit: Boolean!
  sortOrder: Int!
}

input EquipmentCategoryFilterInput {
  isActive: Boolean
  operationType: OperationType
}

type EquipmentCategoryResponse {
  category: EquipmentCategory
  error: String
  success: Boolean!
}

"""Physical condition of equipment"""
enum EquipmentCondition {
  EXCELLENT
  FAIR
  GOOD
  NEEDS_REPAIR
  OUT_OF_SERVICE
}

type EquipmentDeleteResponse {
  error: String
  message: String
  success: Boolean!
}

input EquipmentFilterInput {
  categoryId: ID
  condition: EquipmentCondition

  """Filter by category operation type"""
  operationType: OperationType
  status: EquipmentStatus
}

type EquipmentReleaseResponse {
  error: String
  releasedCount: Int!
  success: Boolean!
}

type EquipmentResponse {
  equipment: Equipment
  error: String
  success: Boolean!
}

"""Availability status of equipment"""
enum EquipmentStatus {
  AVAILABLE
  IN_USE
  MAINTENANCE
  RESERVED
  RETIRED
}

"""Resolution status of an exception"""
enum ExceptionResolution {
  ACKNOWLEDGED
  ADJUSTED
  ESCALATED
  PENDING
  RESOLVED
  WRITTEN_OFF
}

"""Severity level of an exception"""
enum ExceptionSeverity {
  CRITICAL
  HIGH
  LOW
  MEDIUM
}

"""Type of settlement exception"""
enum ExceptionType {
  CARD_VARIANCE
  CASH_VARIANCE
  DISCOUNT_WITHOUT_APPROVAL
  DUPLICATE_TRANSACTION
  MISSING_RECEIPT
  OTHER
  REFUND_WITHOUT_APPROVAL
  SYSTEM_ERROR
  VOID_WITHOUT_APPROVAL
}

input ExemptMemberInput {
  memberSpendId: String!
  reason: String!
}

type ExtendedServiceType {
  basePrice: Float!
  bufferMinutes: Int
  category: String!
  description: String
  durationMinutes: Int!
  id: ID!
  isActive: Boolean!
  maxParticipants: Int
  name: String!
  requiredCapabilities: [String!]
  requiredFacilityFeatures: [String!]
  tierDiscounts: [TierDiscountType!]
  variations: [ServiceVariationType!]
}

type ExtendedStaffType {
  capabilities: [String!]
  certifications: [StaffCertificationType!]
  defaultFacilityId: ID
  detailedCapabilities: [StaffCapabilityType!]
  email: String
  firstName: String!
  id: ID!
  isActive: Boolean!
  lastName: String!
  phone: String
  photoUrl: String
  role: String
  userId: ID
  workingHours: [DayHoursType!]
}

input FacilityFilterInput {
  isActive: Boolean
  type: ResourceTypeEnum
}

type FacilityResponseType {
  error: String
  facility: FacilityType
  success: Boolean!
}

type FacilityType {
  capacity: Int
  id: ID!
  isActive: Boolean!
  location: String
  name: String!
  type: ResourceTypeEnum!
}

type FifoAllocationItem {
  allocatedAmount: String!
  balance: String!
  dueDate: DateTime!
  invoiceId: ID!
  invoiceNumber: String!
}

type FifoAllocationPreview {
  allocations: [FifoAllocationItem!]!
  creditToAdd: String!
  remainingPayment: String!
  totalAllocated: String!
}

type FlightAssignment {
  flightNumber: Int!
  players: [GolfGroupPlayerType!]!
  teeTime: String!
}

type FlightCheckInInfoType {
  caddyAssignment: String
  cartNumber: String
  course: String!
  id: ID!
  players: [CheckInPlayerInfoType!]!
  startingHole: Int!
  teeTime: DateTime!
}

type FlightCheckInResponseType {
  checkedInAt: DateTime!
  success: Boolean!
  teeTime: TeeTimeType!
}

type FlightPaymentSummaryType {
  checkedInCount: Int!
  course: String!
  isFullyCheckedIn: Boolean!
  isFullySettled: Boolean!
  settledCount: Int!
  teeTime: DateTime!
  teeTimeId: ID!
  totalBalance: Float!
  totalDue: Float!
  totalPaid: Float!
  totalPlayers: Int!
}

input GenerateStatementInput {
  endDate: DateTime!
  memberId: ID!
  startDate: DateTime!
}

input GenerateTicketInput {
  forceRegenerate: Boolean = false
  teeTimeId: ID!
}

input GetAutoPayHistoryInput {
  limit: Int = 20
  memberId: String!
}

input GetMemberSpendsInput {
  memberId: String
  periodEnd: DateTime
  periodStart: DateTime
  status: MemberSpendStatus
}

input GetSettlementsInput {
  endDate: DateTime!
  startDate: DateTime!
}

input GetTransactionsInput {
  endDate: DateTime
  startDate: DateTime
  subAccountId: String
}

type GolfCourseIntervalType {
  dayType: DayType!
  id: ID!
  intervalMin: Int!
  isPrimeTime: Boolean!
  timeEnd: String!
  timeStart: String!
}

type GolfCourseScheduleType {
  courseId: ID!
  createdAt: DateTime!
  endDate: DateTime!
  firstTeeTime: String!
  id: ID!
  intervals: [GolfCourseIntervalType!]
  isActive: Boolean!
  lastTeeTime: String!
  paceOfPlay: Int
  playFormat: PlayFormat!
  seasonName: String!
  startDate: DateTime!
  updatedAt: DateTime!
}

type GolfCourseType {
  code: String!
  description: String
  firstTeeTime: String!
  holes: Int!
  id: ID!
  isActive: Boolean!
  lastTeeTime: String!
  name: String!
  par: Int!
  rating: Float
  slope: Float
  teeInterval: Int!
}

type GolfGroupBookingType {
  course: GolfCourseType
  courseId: ID!
  createdAt: DateTime!
  eventDate: DateTime!
  groupName: String!
  id: ID!
  notes: String
  players: [GolfGroupPlayerType!]!
  startFormat: StartFormat!
  startTime: String!
  status: GroupBookingStatus!
  totalPlayers: Int!
  updatedAt: DateTime!
}

type GolfGroupPlayerType {
  assignedFlight: Int
  assignedPosition: Int
  guestEmail: String
  guestName: String
  guestPhone: String
  handicap: Int
  id: ID!
  memberId: ID
  playerType: PlayerType!
}

type GolfLotteryRequestType {
  assignedTime: String
  createdAt: DateTime!
  drawOrder: Int
  id: ID!
  lotteryId: ID!
  member: PlayerMemberType
  memberId: ID!
  playerCount: Int!
  preference1: String!
  preference2: String
  preference3: String
  status: LotteryRequestStatus!
  updatedAt: DateTime!
}

type GolfLotteryType {
  course: GolfCourseType
  courseId: ID!
  createdAt: DateTime!
  drawTime: DateTime!
  id: ID!
  lotteryDate: DateTime!
  lotteryType: LotteryType!
  maxRequestsPerMember: Int!
  requestWindowEnd: DateTime!
  requestWindowStart: DateTime!
  requests: [GolfLotteryRequestType!]
  status: LotteryStatus!
  timeRangeEnd: String!
  timeRangeStart: String!
  totalRequests: Int
  updatedAt: DateTime!
}

type GolfScheduleConfigType {
  clubLatitude: Float
  clubLongitude: Float
  courseId: ID!
  defaultBookingWindowDays: Int!
  id: ID!
  seasons: [GolfSeasonType!]!
  specialDays: [GolfSpecialDayType!]!
  timePeriods: [GolfTimePeriodType!]!
  twilightFixedDefault: String!
  twilightMinutesBeforeSunset: Int!
  twilightMode: TwilightMode!
  weekdayBookingMode: BookingMode!
  weekdayFirstTee: String!
  weekdayLastTee: String!
  weekendBookingMode: BookingMode!
  weekendFirstTee: String!
  weekendLastTee: String!
}

type GolfSeasonType {
  endDay: Int!
  endMonth: Int!
  id: ID!
  isRecurring: Boolean!
  name: String!
  overrideBookingWindow: Int
  overrideFirstTee: String
  overrideLastTee: String
  overrideTimePeriods: Boolean!
  overrideTwilightTime: String
  priority: Int!
  startDay: Int!
  startMonth: Int!
  timePeriods: [GolfTimePeriodType!]!
  weekdayBookingMode: BookingMode
  weekendBookingMode: BookingMode
}

type GolfSpecialDayType {
  bookingMode: BookingMode
  customFirstTee: String
  customLastTee: String
  customTimePeriods: Boolean!
  endDate: String!
  id: ID!
  isRecurring: Boolean!
  name: String!
  notes: String
  startDate: String!
  timePeriods: [GolfTimePeriodType!]!
  type: SpecialDayType!
}

type GolfTimePeriodType {
  applicableDays: ApplicableDays!
  endTime: String
  id: ID!
  intervalMinutes: Int!
  isPrimeTime: Boolean!
  name: String!
  sortOrder: Int!
  startTime: String!
}

"""Golf waitlist entry status"""
enum GolfWaitlistStatus {
  BOOKED
  CANCELLED
  EXPIRED
  NOTIFIED
  PENDING
}

type GolfWaitlistType {
  bookedTeeTimeId: ID
  course: GolfCourseType
  courseId: ID!
  createdAt: DateTime!
  expiresAt: DateTime
  id: ID!
  member: PlayerMemberType
  memberId: ID
  notifiedAt: DateTime
  playerCount: Int!
  priority: Int!
  requestedDate: DateTime!
  requesterEmail: String
  requesterName: String!
  requesterPhone: String!
  status: GolfWaitlistStatus!
  timeRangeEnd: String!
  timeRangeStart: String!
  updatedAt: DateTime!
}

type GreenFeeRateMutationResponse {
  greenFeeRate: GreenFeeRateType
  message: String
  success: Boolean!
}

type GreenFeeRateType {
  amount: Float!
  createdAt: DateTime!
  holes: Int!
  id: ID!
  playerType: String!
  taxRate: Float!
  taxType: String!
  timeCategory: String!
  updatedAt: DateTime!
}

type GroupBookingFlightsResponse {
  flights: [FlightAssignment!]!
  success: Boolean!
  totalFlights: Int!
}

type GroupBookingMutationResponse {
  groupBooking: GolfGroupBookingType
  message: String
  success: Boolean!
  warnings: [String!]
}

"""Group booking status"""
enum GroupBookingStatus {
  CANCELLED
  COMPLETED
  CONFIRMED
  DRAFT
}

input GroupPlayerInput {
  guestEmail: String
  guestName: String
  guestPhone: String
  handicap: Int
  memberId: ID
  playerType: PlayerType!
}

type HouseholdType {
  address: String
  email: String
  id: ID!
  name: String!
  phone: String
}

input ImportPlayersFromCSVInput {
  rows: [CSVPlayerRow!]!
}

"""Interest category for member engagement"""
type InterestCategoryType {
  code: String!
  color: String
  createdAt: DateTime!
  description: String
  icon: String
  id: ID!
  isActive: Boolean!
  name: String!
  sortOrder: Int!
  updatedAt: DateTime!
}

"""Source of the interest data"""
enum InterestSource {
  BOOKING
  EXPLICIT
  INFERRED
}

type InvoiceConnection {
  edges: [InvoiceTypeEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input InvoiceLineItemInput {
  chargeTypeId: ID!
  description: String
  discountPct: Float = 0
  quantity: Float!
  taxRate: Float = 0
  taxType: String
  unitPrice: Float!
}

type InvoiceLineItemType {
  chargeType: ChargeTypeType
  description: String
  discountPct: String!
  id: ID!
  lineTotal: String!
  quantity: Float!
  taxRate: String!
  taxType: String
  unitPrice: String!
}

"""Invoice status options"""
enum InvoiceStatus {
  CANCELLED
  DRAFT
  OVERDUE
  PAID
  PARTIALLY_PAID
  SENT
  VOID
}

type InvoiceType {
  balanceDue: String!
  billingPeriod: String
  createdAt: DateTime!
  discountAmount: String!
  dueDate: DateTime!
  id: ID!
  internalNotes: String
  invoiceDate: DateTime!
  invoiceNumber: String!
  lineItems: [InvoiceLineItemType!]!
  member: MemberSummaryBillingType
  notes: String
  paidAmount: String!
  paidDate: DateTime
  payments: [PaymentAllocationSummaryType!]
  sentAt: DateTime
  status: InvoiceStatus!
  subtotal: String!
  taxAmount: String!
  totalAmount: String!
  updatedAt: DateTime!
  viewedAt: DateTime
}

type InvoiceTypeEdge {
  cursor: String!
  node: InvoiceType!
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

input JoinWaitlistInput {
  facilityId: ID
  memberId: ID!
  notes: String
  requestedDate: String!
  requestedTime: String!
  serviceId: ID
}

"""Preview of late fee calculation"""
type LateFeePreview {
  """Date when late fee would be applied"""
  appliedDate: DateTime!

  """Number of days overdue"""
  daysOverdue: Int!

  """Human-readable description of the late fee"""
  description: String!

  """Late fee amount in cents"""
  feeAmount: Float!

  """Whether the invoice is still within grace period"""
  isWithinGracePeriod: Boolean!
}

input LateFeePreviewInput {
  """Date to calculate late fee as of (defaults to today)"""
  calculationDate: DateTime
  invoiceId: ID!
}

"""Late fee type options"""
enum LateFeeType {
  FIXED
  PERCENTAGE
  TIERED
}

type LineItemPaymentType {
  amount: Float!
  description: String
  id: ID!
  lineItemId: ID!
}

"""Type of booking line item"""
enum LineItemType {
  CADDY
  CART
  GREEN_FEE
  PROSHOP
  RENTAL
}

type LookupCategory {
  code: String!
  description: String
  id: ID!
  isGlobal: Boolean!
  isSystem: Boolean!
  name: String!
  sortOrder: Int!
  valueCount: Int!
  values: [LookupValue!]
}

input LookupCategoryFilterInput {
  isGlobal: Boolean
  isSystem: Boolean
}

type LookupMutationResult {
  error: String
  message: String
  success: Boolean!
  translation: LookupTranslation
  value: LookupValue
}

type LookupTranslation {
  description: String
  id: ID!
  locale: String!
  lookupValueId: String!
  name: String!
}

type LookupValue {
  category: LookupCategory
  categoryId: String!
  clubId: String
  code: String!
  color: String
  description: String
  icon: String
  id: ID!
  isActive: Boolean!
  isDefault: Boolean!
  metadata: JSON
  name: String!
  sortOrder: Int!
  translations: [LookupTranslation!]
}

type LotteryDrawResult {
  assignedCount: Int!
  lottery: GolfLotteryType
  message: String
  success: Boolean!
  totalRequests: Int!
  waitlistedCount: Int!
}

type LotteryMutationResponse {
  lottery: GolfLotteryType
  message: String
  success: Boolean!
}

type LotteryRequestMutationResponse {
  message: String
  request: GolfLotteryRequestType
  success: Boolean!
}

"""Lottery request status"""
enum LotteryRequestStatus {
  ASSIGNED
  CANCELLED
  PENDING
  WAITLISTED
}

"""Lottery status"""
enum LotteryStatus {
  CLOSED
  DRAFT
  DRAWN
  OPEN
  PUBLISHED
}

"""Type of lottery"""
enum LotteryType {
  PRIME_TIME
  SPECIAL_EVENT
}

type MemberAddressType {
  addressLine1: String!
  addressLine2: String
  country: String!
  createdAt: DateTime!
  district: String!
  id: ID!
  isPrimary: Boolean!
  label: String
  postalCode: String!
  province: String!
  subDistrict: String!
  type: AddressType!
  updatedAt: DateTime!
}

type MemberAtRiskType {
  creditLimit: Float!
  firstName: String!
  id: ID!
  isAtRisk: Boolean!
  isExceeded: Boolean!
  lastName: String!
  memberId: String!
  outstandingBalance: Float!
  usagePercent: Float!
}

"""Member-specific billing profile with optional overrides"""
type MemberBillingProfileType {
  """Override cycle alignment for this member"""
  billingAlignment: CycleAlignment

  """Override billing frequency for this member"""
  billingFrequency: BillingFrequency

  """Whether billing is on hold for this member"""
  billingHold: Boolean!

  """Reason for placing billing on hold"""
  billingHoldReason: String

  """Date until which billing is on hold"""
  billingHoldUntil: DateTime

  """Override billing timing for this member"""
  billingTiming: BillingTiming

  """When the profile was created"""
  createdAt: DateTime!

  """Current billing period end date"""
  currentPeriodEnd: DateTime

  """Current billing period start date"""
  currentPeriodStart: DateTime

  """Custom billing day of month (1-28)"""
  customBillingDay: Int

  """Custom grace period in days"""
  customGracePeriod: Int

  """Whether this member is exempt from late fees"""
  customLateFeeExempt: Boolean!
  id: ID!

  """Last billing date processed"""
  lastBillingDate: DateTime

  """Associated member information"""
  member: MemberBillingSummary
  memberId: ID!

  """Next scheduled billing date"""
  nextBillingDate: DateTime

  """Internal notes about this billing profile"""
  notes: String

  """Override proration method for this member"""
  prorationOverride: ProrationMethod

  """When the profile was last updated"""
  updatedAt: DateTime!
}

"""Minimal member summary for billing contexts"""
type MemberBillingSummary {
  firstName: String!
  id: ID!
  lastName: String!

  """Member ID number"""
  memberId: String!
}

"""Member communication preferences"""
type MemberCommunicationPrefsType {
  createdAt: DateTime!
  emailPromotions: Boolean!
  id: ID!
  memberId: ID!
  pushNotifications: Boolean!
  smsPromotions: Boolean!
  unsubscribedCategories: [String!]!
  updatedAt: DateTime!
}

type MemberConnection {
  edges: [MemberTypeEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

"""Single interest entry for a member"""
input MemberInterestInput {
  categoryId: ID!
  interestLevel: Int!
  source: InterestSource
}

"""Member interest in an activity category"""
type MemberInterestType {
  activityCount: Int!
  category: InterestCategoryType
  categoryId: ID!
  createdAt: DateTime!
  id: ID!

  """Interest level 0-100"""
  interestLevel: Int!
  lastActivityAt: DateTime
  memberId: ID!
  source: InterestSource!
  updatedAt: DateTime!
}

type MemberMinimumSpend {
  carryForwardAmount: Float!
  clubId: String!
  createdAt: DateTime!
  currentSpend: Float!
  exemptAt: DateTime
  exemptBy: String
  exemptReason: String
  id: ID!
  isExempt: Boolean!
  lastCalculatedAt: DateTime!
  memberId: String!
  periodEnd: DateTime!
  periodLabel: String!
  periodStart: DateTime!
  projectedSpend: Float
  requiredAmount: Float!
  requirement: MinimumSpendRequirement
  requirementId: String!
  shortfallAction: ShortfallAction
  shortfallAmount: Float
  shortfallInvoiceId: String
  shortfallNote: String
  shortfallResolvedAt: DateTime
  shortfallResolvedBy: String
  status: MemberSpendStatus!
  updatedAt: DateTime!
}

"""Status of member spending against requirement"""
enum MemberSpendStatus {
  AT_RISK
  EXEMPT
  MET
  ON_TRACK
  PENDING_ACTION
  RESOLVED
  SHORTFALL
}

type MemberStatementInfoType {
  address: String
  email: String
  id: ID!
  memberNumber: String!
  membershipType: String!
  name: String!
}

type MemberStatsType {
  active: Float!
  inactive: Float!
  suspended: Float!
  total: Float!
}

"""Member status options"""
enum MemberStatus {
  ACTIVE
  APPLICANT
  LAPSED
  LEAD
  PROSPECT
  REACTIVATED
  RESIGNED
  SUSPENDED
  TERMINATED
}

type MemberSummaryBillingType {
  firstName: String!
  id: ID!
  lastName: String!
  memberId: String!
}

type MemberSummaryType {
  firstName: String!
  id: ID!
  isPrimaryMember: Boolean
  lastName: String!
  memberId: String!
}

type MemberTransactionType {
  amount: String!
  date: DateTime!
  description: String!
  id: ID!
  invoiceNumber: String
  runningBalance: String!
  type: String!
}

type MemberTransactionsType {
  currentBalance: String!
  transactions: [MemberTransactionType!]!
}

type MemberType {
  address: String
  addresses: [MemberAddressType!]
  avatarUrl: String
  createdAt: DateTime!
  creditBalance: String!
  dateOfBirth: DateTime
  dependents: [DependentType!]
  email: String
  emergencyContact: String
  emergencyPhone: String
  expiryDate: DateTime
  firstName: String!
  gender: String
  household: HouseholdType
  id: ID!
  idNumber: String
  isActive: Boolean!
  isPrimaryMember: Boolean!
  joinDate: DateTime!
  lastName: String!
  memberId: String!
  membershipTier: MembershipTierType
  membershipType: MembershipTypeType
  nationality: String
  notes: String
  outstandingBalance: String!
  phone: String
  referredBy: MemberSummaryType
  renewalDate: DateTime
  status: MemberStatus!
  tags: [String!]!
  updatedAt: DateTime!
}

type MemberTypeEdge {
  cursor: String!
  node: MemberType!
}

type MembershipApplicationType {
  applicationNumber: String!
  approvedAt: DateTime
  approvedBy: String
  createdAt: DateTime!
  email: String!
  firstName: String!
  id: ID!
  lastName: String!
  membershipType: ApplicationMembershipTypeType!
  phone: String
  rejectedAt: DateTime
  rejectedBy: String
  rejectionReason: String
  reviewNotes: String
  reviewedAt: DateTime
  reviewedBy: String
  sponsor: ApplicationSponsorType
  status: ApplicationStatus!
  submittedAt: DateTime!
  updatedAt: DateTime!
  withdrawnAt: DateTime
}

type MembershipApplicationTypeEdge {
  cursor: String!
  node: MembershipApplicationType!
}

type MembershipTierType {
  code: String!
  description: String
  id: ID!
  name: String!
}

type MembershipTypeType {
  allowFamilyMembers: Boolean!
  allowGuests: Boolean!
  annualFee: Float
  bookingAdvanceDays: Float!
  code: String!
  description: String
  id: ID!
  joiningFee: Float
  maxFamilyMembers: Float!
  maxGuestsPerBooking: Float!
  monthlyFee: Float
  name: String!
  priorityBooking: Boolean!
}

"""Period for minimum spend requirements"""
enum MinimumSpendPeriod {
  ANNUALLY
  MONTHLY
  QUARTERLY
}

type MinimumSpendRequirement {
  allowPartialCredit: Boolean!
  clubId: String!
  createdAt: DateTime!
  defaultShortfallAction: ShortfallAction!
  description: String
  effectiveFrom: DateTime!
  effectiveTo: DateTime
  excludedCategories: [String!]!
  gracePeriodDays: Int!
  id: ID!
  includeEvents: Boolean!
  includeFoodBeverage: Boolean!
  includeGolf: Boolean!
  includeRetail: Boolean!
  includeSpa: Boolean!
  includedCategories: [String!]!
  isActive: Boolean!
  membershipTypes: [String!]!
  minimumAmount: Float!
  name: String!
  notifyAtPercent: [Int!]!
  notifyDaysBeforeEnd: [Int!]!
  period: MinimumSpendPeriod!
  updatedAt: DateTime!
}

type Modifier {
  id: ID!
  isActive: Boolean!
  isDefault: Boolean!
  name: String!
  priceAdjustment: Float!
  sortOrder: Int!
}

type ModifierGroup {
  id: ID!
  isActive: Boolean!
  maxSelections: Int
  minSelections: Int!
  modifiers: [Modifier!]!
  name: String!
  selectionType: ModifierSelectionType!
  sortOrder: Int!
}

enum ModifierSelectionType {
  MULTIPLE
  SINGLE
}

input MoveTeeTimeInput {
  newCourseId: ID
  newTeeDate: DateTime!
  newTeeTime: String!
}

type Mutation {
  """Accept a waitlist offer"""
  acceptWaitlistOffer(input: WaitlistActionInput!): WaitlistResponseType!

  """Add players to a group booking"""
  addGroupPlayers(id: ID!, input: AddGroupPlayersInput!): GroupBookingMutationResponse!

  """Add a line item to a player"""
  addLineItem(input: AddLineItemInput!): BookingLineItemType!
  addLookupTranslation(input: AddLookupTranslationInput!): LookupMutationResult!

  """Add a new stored payment method"""
  addPaymentMethod(input: AddStoredPaymentInput!): StoredPaymentMethod!

  """Apply credit note to member balance"""
  applyCreditNoteToBalance(id: ID!): CreditNoteGraphQLType!

  """Apply credit note to a specific invoice"""
  applyCreditNoteToInvoice(id: ID!, input: ApplyCreditNoteInput!): CreditNoteGraphQLType!

  """Apply a discount to a line item or transaction"""
  applyDiscount(input: ApplyDiscountInput!): ApplyDiscountResultType!

  """Apply a discount using a promo code"""
  applyDiscountByCode(input: ApplyDiscountByCodeInput!): ApplyDiscountResultType!

  """Approve a credit note"""
  approveCreditNote(id: ID!): CreditNoteGraphQLType!

  """Approve a pending discount that requires manager approval"""
  approveDiscount(input: ApproveDiscountInput!): AppliedDiscountType!
  assignEquipment(input: AssignEquipmentInput!): EquipmentAssignmentResponse!

  """Auto-assign players to flights"""
  assignFlights(id: ID!, interval: Float! = 8): GroupBookingFlightsResponse!

  """Assign a template to an outlet"""
  assignPOSTemplate(input: AssignTemplateInput!): AssignTemplateMutationResponse!

  """Batch settle invoices using FIFO allocation"""
  batchSettleInvoices(input: BatchSettlementInput!): BatchSettlementResult!

  """Remove multiple line items"""
  bulkRemoveLineItems(input: BulkRemoveLineItemsInput!): BulkRemoveResultType!

  """Transfer multiple line items to another player"""
  bulkTransferLineItems(input: BulkTransferLineItemsInput!): BulkTransferResultType!
  bulkUpdateOutletProductConfigs(input: BulkOutletProductConfigInput!, outletId: ID!): [OutletProductConfig!]!

  """Bulk update multiple pro shop products"""
  bulkUpdateProShopProducts(ids: [ID!]!, input: BulkUpdateProShopProductInput!): [ProShopProductType!]!

  """Cancel a booking"""
  cancelBooking(input: CancelBookingInput!): CancelBookingResponseType!

  """Cancel a group booking"""
  cancelGroupBooking(id: ID!): GroupBookingMutationResponse!

  """Cancel a lottery request"""
  cancelLotteryRequest(id: ID!): LotteryRequestMutationResponse!

  """Cancel a tee time"""
  cancelTeeTime(id: ID!, reason: String): CancelResponseType!

  """Cancel a waitlist entry"""
  cancelWaitlistEntry(id: ID!): WaitlistMutationResponse!

  """Change the status of a membership application"""
  changeApplicationStatus(id: ID!, input: ChangeApplicationStatusInput!): MembershipApplicationType!

  """Change member status"""
  changeMemberStatus(id: ID!, input: ChangeStatusInput!): MemberType!

  """Change a sub-account PIN"""
  changeSubAccountPin(input: ChangePinInput!): SubAccount!

  """Change a sub-account status"""
  changeSubAccountStatus(input: ChangeSubAccountStatusInput!): SubAccount!

  """Check in a booking"""
  checkIn(input: CheckInInput!): CheckInResponseType!

  """Check in all players in a flight at once"""
  checkInAllPlayers(input: CheckInAllPlayersInput!): CheckInResultType!

  """Check in multiple players for a flight"""
  checkInFlight(input: CheckInFlightInput!): CheckInResultType!

  """Check in multiple players at once"""
  checkInSlots(input: CheckInSlotsInput!): CheckInSlotsResultType!

  """Clear cart draft for a tee time"""
  clearCartDraft(teeTimeId: ID!): Boolean!

  """Clone a POS template with a new name"""
  clonePOSTemplate(id: ID!, newName: String!): CloneTemplateMutationResponse!

  """Close a lottery to new requests"""
  closeLottery(id: ID!): LotteryMutationResponse!

  """Close a minimum spend period and process shortfalls"""
  closeMinimumSpendPeriod(input: ClosePeriodInput!): [MemberMinimumSpend!]!

  """Close a settlement"""
  closeSettlement(input: CloseSettlementInput!): DailySettlementGraphQLType!

  """Close a shift"""
  closeShift(input: CloseShiftInput!): CashDrawerShiftGraphQLType!

  """Confirm group booking and create tee times"""
  confirmGroupBooking(id: ID!): GroupBookingMutationResponse!

  """Convert a waitlist entry to a booking"""
  convertWaitlistToBooking(id: ID!, teeTimeId: ID!): WaitlistMutationResponse!

  """Create a new membership application"""
  createApplication(input: CreateApplicationInput!): MembershipApplicationType!

  """Create a new booking"""
  createBooking(input: CreateBookingInput!): CreateBookingResponseType!

  """Create a caddy rate"""
  createCaddyRate(input: CreateCaddyRateInput!): CaddyRateMutationResponse!

  """Create a cart rate"""
  createCartRate(input: CreateCartRateInput!): CartRateMutationResponse!

  """Create a new cash drawer"""
  createCashDrawer(input: CreateCashDrawerInput!): CashDrawerGraphQLType!

  """Create a new payment method for check-in"""
  createCheckInPaymentMethod(input: CreatePaymentMethodInput!): CheckInPaymentMethodType!

  """Create a course schedule"""
  createCourseSchedule(input: CreateScheduleInput!): ScheduleMutationResponse!

  """Create a new credit note"""
  createCreditNote(input: CreateCreditNoteInput!): CreditNoteGraphQLType!

  """Create a credit limit override (temporary or permanent increase)"""
  createCreditOverride(input: CreateCreditOverrideInput!): CreditLimitOverrideType!

  """Create default schedule configuration for a course"""
  createDefaultScheduleConfig(courseId: ID!): ScheduleConfigMutationResponse!

  """Add a dependent to a member"""
  createDependent(input: CreateDependentInput!): DependentType!

  """Create a new discount"""
  createDiscount(input: CreateDiscountInput!): DiscountGraphQLType!
  createEquipment(input: CreateEquipmentInput!): EquipmentResponse!
  createEquipmentCategory(input: CreateEquipmentCategoryInput!): EquipmentCategoryResponse!

  """Create a new facility"""
  createFacility(input: CreateFacilityInput!): FacilityResponseType!

  """Create a green fee rate"""
  createGreenFeeRate(input: CreateGreenFeeRateInput!): GreenFeeRateMutationResponse!

  """Create a group booking"""
  createGroupBooking(input: CreateGroupBookingInput!): GroupBookingMutationResponse!

  """Create a new interest category"""
  createInterestCategory(input: CreateInterestCategoryInput!): InterestCategoryType!

  """Create a new invoice"""
  createInvoice(input: CreateInvoiceInput!): InvoiceType!
  createLookupValue(input: CreateLookupValueInput!): LookupMutationResult!

  """Create a lottery"""
  createLottery(input: CreateLotteryInput!): LotteryMutationResponse!

  """Create a new member"""
  createMember(input: CreateMemberInput!): MemberType!

  """Create a new member address"""
  createMemberAddress(input: CreateAddressInput!): MemberAddressType!

  """Create a billing profile for a member with custom settings"""
  createMemberBillingProfile(input: CreateMemberBillingProfileInput!): MemberBillingProfileType!

  """Create a new minimum spend requirement"""
  createMinimumSpendRequirement(input: CreateRequirementInput!): MinimumSpendRequirement!
  createModifierGroup(input: CreateModifierGroupInput!): ModifierGroup!

  """Create a new pro shop category"""
  createProShopCategory(input: CreateProShopCategoryInput!): ProShopCategoryType!

  """Create a new pro shop product"""
  createProShopProduct(input: CreateProShopProductInput!): ProShopProductType!
  createProduct(input: CreateProductInput!): Product!
  createProductCategory(input: CreateProductCategoryInput!): ProductCategory!

  """Create a rate configuration"""
  createRateConfig(input: CreateRateConfigInput!): RateConfigMutationResponse!

  """Create a season"""
  createSeason(input: CreateSeasonInput!, scheduleId: ID!): SeasonMutationResponse!

  """Create a new service"""
  createService(input: CreateServiceInput!): ServiceResponseType!

  """Create a settlement exception"""
  createSettlementException(input: CreateExceptionInput!): SettlementExceptionGraphQLType!

  """Create a special day"""
  createSpecialDay(input: CreateSpecialDayInput!, scheduleId: ID!): SpecialDayMutationResponse!

  """Create a new staff member"""
  createStaffMember(input: CreateStaffMemberInput!): StaffResponseType!

  """Create a new sub-account"""
  createSubAccount(input: CreateSubAccountInput!): SubAccount!

  """Create a new tee time booking"""
  createTeeTime(input: CreateTeeTimeInput!): TeeTimeType!

  """Create a tee time block"""
  createTeeTimeBlock(input: CreateBlockInput!): BlockMutationResponse!

  """Create a time period"""
  createTimePeriod(input: CreateTimePeriodInput!, scheduleId: ID!): TimePeriodMutationResponse!

  """Add to waitlist"""
  createWaitlistEntry(input: CreateWaitlistEntryInput!): WaitlistMutationResponse!

  """Decline a waitlist offer"""
  declineWaitlistOffer(input: WaitlistActionInput!): WaitlistResponseType!

  """Delete a caddy rate"""
  deleteCaddyRate(id: ID!): DeleteRateMutationResponse!

  """Delete a cart rate"""
  deleteCartRate(id: ID!): DeleteRateMutationResponse!

  """Delete a payment method"""
  deleteCheckInPaymentMethod(id: ID!): Boolean!

  """Delete a course schedule"""
  deleteCourseSchedule(id: ID!): ScheduleMutationResponse!

  """Delete a dependent"""
  deleteDependent(id: ID!): DeleteDependentResponseType!

  """Delete a discount (soft delete)"""
  deleteDiscount(id: ID!): Boolean!
  deleteEquipment(id: ID!): EquipmentDeleteResponse!
  deleteEquipmentCategory(id: ID!): EquipmentDeleteResponse!

  """Delete a facility"""
  deleteFacility(id: ID!): DeleteResponseType!

  """Delete a green fee rate"""
  deleteGreenFeeRate(id: ID!): DeleteRateMutationResponse!

  """Delete a draft group booking"""
  deleteGroupBooking(id: ID!): GroupBookingMutationResponse!

  """Delete an interest category"""
  deleteInterestCategory(id: ID!): EngagementDeleteResponse!
  deleteLookupTranslation(id: ID!): LookupMutationResult!
  deleteLookupValue(id: ID!): LookupMutationResult!

  """Delete a draft lottery"""
  deleteLottery(id: ID!): LotteryMutationResponse!

  """Soft delete a member"""
  deleteMember(id: ID!): DeleteMemberResponseType!

  """Delete a member address"""
  deleteMemberAddress(id: ID!): DeleteAddressResponseType!

  """Delete (deactivate) a minimum spend requirement"""
  deleteMinimumSpendRequirement(id: ID!): MinimumSpendRequirement!

  """Delete a POS template"""
  deletePOSTemplate(id: ID!): DeleteTemplateMutationResponse!

  """
  Delete a pro shop category. If category has products, provide moveProductsTo.
  """
  deleteProShopCategory(id: ID!, moveProductsTo: ID): Boolean!

  """Delete a pro shop product"""
  deleteProShopProduct(id: ID!): Boolean!
  deleteProduct(id: ID!): Boolean!
  deleteProductCategory(id: ID!, moveProductsTo: ID): Boolean!

  """Delete a rate configuration"""
  deleteRateConfig(id: ID!): DeleteRateMutationResponse!

  """Delete a season"""
  deleteSeason(id: ID!): DeleteMutationResponse!

  """Delete a service"""
  deleteService(id: ID!): DeleteResponseType!

  """Delete a special day"""
  deleteSpecialDay(id: ID!): DeleteMutationResponse!

  """Delete a staff member"""
  deleteStaffMember(id: ID!): DeleteResponseType!

  """Delete (revoke) a sub-account"""
  deleteSubAccount(id: ID!): SubAccount!

  """Delete a tee time block"""
  deleteTeeTimeBlock(id: ID!): BlockMutationResponse!

  """Delete a time period"""
  deleteTimePeriod(id: ID!): DeleteMutationResponse!

  """Delete a waitlist entry"""
  deleteWaitlistEntry(id: ID!): WaitlistMutationResponse!

  """Disable auto-pay for a member"""
  disableAutoPay(memberId: ID!): RemovePaymentMethodResult!

  """Execute the lottery draw"""
  executeLotteryDraw(id: ID!): LotteryDrawResult!

  """Exempt a member from a minimum spend requirement"""
  exemptMemberFromMinimumSpend(input: ExemptMemberInput!): MemberMinimumSpend!

  """Mark expired waitlist entries"""
  expireOldWaitlistEntries: WaitlistMutationResponse!

  """Generate or regenerate a starter ticket for a tee time"""
  generateStarterTicket(input: GenerateTicketInput!): StarterTicketResponseType!

  """Import players from CSV data"""
  importPlayersFromCSV(id: ID!, input: ImportPlayersFromCSVInput!): GroupBookingMutationResponse!

  """Join a waitlist"""
  joinWaitlist(input: JoinWaitlistInput!): WaitlistResponseType!

  """Move a tee time to a different slot"""
  moveTeeTime(id: ID!, input: MoveTeeTimeInput!): TeeTimeType!

  """Notify waitlist when a tee time is cancelled"""
  notifyWaitlistForCancellation(availableSpots: Float! = 4, courseId: ID!, date: DateTime!, time: String!): WaitlistNotificationResult!

  """Open a new business day"""
  openDay(input: OpenDayInput!): DailySettlementGraphQLType!

  """Open a lottery for requests"""
  openLottery(id: ID!): LotteryMutationResponse!

  """Open a new shift on a cash drawer"""
  openShift(input: OpenShiftInput!): CashDrawerShiftGraphQLType!

  """Pay specific line items"""
  payLineItems(input: PayLineItemsInput!): PayLineItemsResultType!

  """Mark a starter ticket as printed"""
  printStarterTicket(input: PrintTicketInput!): StarterTicketResponseType!

  """Manually process an auto-pay for an invoice"""
  processAutoPay(input: ProcessAutoPayInput!): AutoPayResult!

  """Process payment for multiple players at once"""
  processBatchPayment(input: BatchPaymentInput!): BatchPaymentResultType!

  """Process payment settlement for players"""
  processSettlement(input: ProcessSettlementInput!): SettlementResultType!

  """Publish lottery results and create tee times"""
  publishLotteryResults(id: ID!): LotteryMutationResponse!

  """Recalculate member spend from transactions"""
  recalculateMemberSpend(memberSpendId: ID!): MemberMinimumSpend!

  """Recalculate settlement totals from transactions"""
  recalculateSettlementTotals(settlementId: ID!): DailySettlementGraphQLType!

  """Record actual cash count"""
  recordCashCount(input: RecordCashCountInput!): DailySettlementGraphQLType!

  """Record a cash movement"""
  recordCashMovement(approvedBy: ID, input: RecordMovementInput!): CashMovementGraphQLType!

  """Record spending against a member minimum spend requirement"""
  recordMinimumSpend(input: RecordSpendInput!): MemberMinimumSpend!

  """Record a payment"""
  recordPayment(input: CreatePaymentInput!): PaymentType!

  """Record a transaction for a sub-account"""
  recordSubAccountTransaction(input: RecordTransactionInput!): SubAccountTransaction!

  """Manually regenerate line items for a tee time"""
  regenerateLineItems(teeTimeId: ID!): Boolean!
  releaseEquipmentForBooking(bookingId: ID!): EquipmentReleaseResponse!

  """Remove an applied discount"""
  removeAppliedDiscount(appliedDiscountId: ID!): Boolean!

  """Remove a specific interest from a dependent"""
  removeDependentInterest(categoryId: ID!, dependentId: ID!): EngagementDeleteResponse!

  """Remove entry from waitlist"""
  removeFromWaitlist(input: WaitlistActionInput!): WaitlistResponseType!

  """Remove a player from a group booking"""
  removeGroupPlayer(groupBookingId: ID!, playerId: ID!): GroupBookingMutationResponse!

  """Remove a line item from cart"""
  removeLineItem(input: RemoveLineItemInput!): RemoveLineItemResultType!

  """Remove a specific interest from a member"""
  removeMemberInterest(categoryId: ID!, memberId: ID!): EngagementDeleteResponse!

  """Remove minimum spend exemption from a member"""
  removeMinimumSpendExemption(memberSpendId: ID!): MemberMinimumSpend!

  """Remove a stored payment method"""
  removePaymentMethod(id: ID!): RemovePaymentMethodResult!

  """Reopen a closed settlement"""
  reopenSettlement(input: ReopenSettlementInput!): DailySettlementGraphQLType!

  """Reorder payment methods by providing ordered IDs"""
  reorderCheckInPaymentMethods(orderedIds: [ID!]!): [CheckInPaymentMethodType!]!

  """Reorder pro shop categories by providing ordered IDs"""
  reorderProShopCategories(orderedIds: [ID!]!): [ProShopCategoryType!]!

  """Reschedule a booking"""
  rescheduleBooking(input: RescheduleBookingInput!): CreateBookingResponseType!

  """Reset all check-in settings to defaults"""
  resetCheckInSettings: CheckInSettingsType!

  """Reset all spending counters for a sub-account"""
  resetSubAccountSpending(subAccountId: ID!): SubAccount!

  """Resolve a minimum spend shortfall"""
  resolveMinimumSpendShortfall(input: ResolveShortfallInput!): MemberMinimumSpend!

  """Resolve a settlement exception"""
  resolveSettlementException(input: ResolveExceptionInput!): SettlementExceptionGraphQLType!

  """Resume a suspended shift"""
  resumeShift(shiftId: ID!): CashDrawerShiftGraphQLType!

  """Retry a failed auto-pay attempt"""
  retryAutoPayAttempt(attemptId: ID!): AutoPayResult!
  returnEquipment(input: ReturnEquipmentInput!): EquipmentAssignmentResponse!

  """Revert a credit limit override"""
  revertCreditOverride(overrideId: ID!): Boolean!

  """Save cart draft for a tee time"""
  saveCartDraft(input: SaveCartDraftInput!): CartDraftType!

  """Send an invoice"""
  sendInvoice(id: ID!): InvoiceType!

  """Send offer to waitlist entry"""
  sendWaitlistOffer(input: SendWaitlistOfferInput!): WaitlistResponseType!

  """Set a payment method as default"""
  setDefaultPaymentMethod(id: ID!): StoredPaymentMethod!

  """Set interests for a dependent (upserts)"""
  setDependentInterests(input: SetDependentInterestsInput!): [DependentInterestType!]!

  """Set interests for a member (upserts)"""
  setMemberInterests(input: SetMemberInterestsInput!): [MemberInterestType!]!

  """Set role-specific button overrides for an outlet"""
  setPOSRoleOverrides(input: POSRoleOverridesInput!, outletId: ID!): SetRoleOverridesMutationResponse!

  """Settle all players in a flight at once"""
  settleAllPlayers(input: SettleAllPlayersInput!): SettlementResultType!

  """Submit a lottery request (member)"""
  submitLotteryRequest(input: CreateLotteryRequestInput!): LotteryRequestMutationResponse!

  """Submit settlement for review"""
  submitSettlementForReview(settlementId: ID!): DailySettlementGraphQLType!

  """Suspend a shift temporarily"""
  suspendShift(shiftId: ID!): CashDrawerShiftGraphQLType!

  """Enable or disable a payment method"""
  toggleCheckInPaymentMethod(id: ID!, isEnabled: Boolean!): CheckInPaymentMethodType!

  """Toggle quick add status for a product"""
  toggleProductQuickAdd(id: ID!, isQuickAdd: Boolean!): ProShopProductType!

  """Transfer a line item from one player to another"""
  transferLineItem(input: TransferLineItemInput!): TransferResultType!

  """Undo a player check-in"""
  undoCheckIn(input: UndoCheckInInput!): Boolean!

  """Undo a line item transfer"""
  undoTransfer(input: UndoTransferInput!): TransferResultType!

  """Unlock a locked sub-account PIN"""
  unlockSubAccountPin(subAccountId: ID!): SubAccount!

  """Update an existing membership application"""
  updateApplication(id: ID!, input: UpdateApplicationInput!): MembershipApplicationType!

  """Update a caddy rate"""
  updateCaddyRate(id: ID!, input: UpdateCaddyRateInput!): CaddyRateMutationResponse!

  """Update a cart rate"""
  updateCartRate(id: ID!, input: UpdateCartRateInput!): CartRateMutationResponse!

  """Update a cash drawer"""
  updateCashDrawer(input: UpdateCashDrawerInput!): CashDrawerGraphQLType!

  """Update an existing payment method"""
  updateCheckInPaymentMethod(id: ID!, input: UpdatePaymentMethodInput!): CheckInPaymentMethodType!

  """Update check-in policy settings"""
  updateCheckInPolicy(input: CheckInPolicyInput!): CheckInSettingsType!

  """Update club-wide billing configuration settings"""
  updateClubBillingSettings(input: UpdateClubBillingSettingsInput!): ClubBillingSettingsType!

  """Update a course schedule"""
  updateCourseSchedule(id: ID!, input: UpdateScheduleInput!): ScheduleMutationResponse!

  """Update a dependent"""
  updateDependent(id: ID!, input: UpdateDependentInput!): DependentType!

  """Update an existing discount"""
  updateDiscount(id: ID!, input: UpdateDiscountInput!): DiscountGraphQLType!
  updateEquipment(input: UpdateEquipmentInput!): EquipmentResponse!
  updateEquipmentCategory(input: UpdateEquipmentCategoryInput!): EquipmentCategoryResponse!
  updateEquipmentStatus(input: UpdateEquipmentStatusInput!): EquipmentResponse!

  """Update an existing facility"""
  updateFacility(input: UpdateFacilityInput!): FacilityResponseType!

  """Update a green fee rate"""
  updateGreenFeeRate(id: ID!, input: UpdateGreenFeeRateInput!): GreenFeeRateMutationResponse!

  """Update a group booking"""
  updateGroupBooking(id: ID!, input: UpdateGroupBookingInput!): GroupBookingMutationResponse!

  """Update an existing interest category"""
  updateInterestCategory(id: ID!, input: UpdateInterestCategoryInput!): InterestCategoryType!

  """Update line item quantity"""
  updateLineItemQuantity(input: UpdateLineItemQuantityInput!): UpdateQuantityResultType!
  updateLookupValue(input: UpdateLookupValueInput!): LookupMutationResult!

  """Update a lottery"""
  updateLottery(id: ID!, input: UpdateLotteryInput!): LotteryMutationResponse!

  """Update an existing member"""
  updateMember(id: ID!, input: UpdateMemberInput!): MemberType!

  """Update an existing member address"""
  updateMemberAddress(id: ID!, input: UpdateAddressInput!): MemberAddressType!

  """Update billing profile for a member"""
  updateMemberBillingProfile(input: UpdateMemberBillingProfileInput!, memberId: ID!): MemberBillingProfileType!

  """Update communication preferences for a member"""
  updateMemberCommunicationPrefs(input: UpdateCommunicationPrefsInput!): MemberCommunicationPrefsType!

  """Update credit limit settings for a member"""
  updateMemberCreditSettings(input: UpdateCreditSettingsInput!): Boolean!

  """Update a minimum spend requirement"""
  updateMinimumSpendRequirement(input: UpdateRequirementInput!): MinimumSpendRequirement!
  updateModifierGroup(id: ID!, input: UpdateModifierGroupInput!): ModifierGroup!
  updateOutletGridConfig(input: UpdateOutletGridConfigInput!, outletId: ID!): OutletGridConfig!
  updateOutletProductConfig(input: UpdateOutletProductConfigInput!, outletId: ID!, productId: ID!): OutletProductConfig!

  """Update the button registry for the club"""
  updatePOSButtonRegistry(input: UpdateButtonRegistryInput!): UpdateButtonRegistryMutationResponse!

  """Update POS integration settings"""
  updatePOSConfig(input: POSConfigInput!): CheckInSettingsType!

  """Update a stored payment method"""
  updatePaymentMethod(input: UpdateStoredPaymentInput!): StoredPaymentMethod!

  """Update a single player rental status (cart/caddy)"""
  updatePlayerRentalStatus(input: UpdatePlayerRentalStatusInput!, playerId: ID!): TeeTimePlayerType!

  """Update an existing pro shop category"""
  updateProShopCategory(id: ID!, input: UpdateProShopCategoryInput!): ProShopCategoryType!

  """Update pro shop integration settings"""
  updateProShopConfig(input: ProShopConfigInput!): CheckInSettingsType!

  """Update an existing pro shop product"""
  updateProShopProduct(id: ID!, input: UpdateProShopProductInput!): ProShopProductType!
  updateProduct(id: ID!, input: UpdateProductInput!): Product!
  updateProductCategory(id: ID!, input: UpdateProductCategoryInput!): ProductCategory!

  """Update a rate configuration"""
  updateRateConfig(id: ID!, input: UpdateRateConfigInput!): RateConfigMutationResponse!

  """Update schedule configuration"""
  updateScheduleConfig(id: ID!, input: UpdateScheduleConfigInput!): ScheduleConfigMutationResponse!

  """Update a season"""
  updateSeason(id: ID!, input: UpdateSeasonInput!): SeasonMutationResponse!

  """Update an existing service"""
  updateService(input: UpdateServiceInput!): ServiceResponseType!

  """Update settlement totals"""
  updateSettlementTotals(input: UpdateSettlementTotalsInput!): DailySettlementGraphQLType!
  updateSmartSuggestionConfig(input: UpdateSmartSuggestionConfigInput!, outletId: ID!): SmartSuggestionConfig!

  """Update a special day"""
  updateSpecialDay(id: ID!, input: UpdateSpecialDayInput!): SpecialDayMutationResponse!

  """Update a staff member"""
  updateStaffMember(input: UpdateStaffMemberInput!): StaffResponseType!

  """Update starter ticket configuration"""
  updateStarterTicketConfig(input: StarterTicketConfigInput!): CheckInSettingsType!

  """Update a sub-account"""
  updateSubAccount(input: UpdateSubAccountInput!): SubAccount!

  """Update tax configuration including overrides"""
  updateTaxConfig(input: TaxConfigInput!): CheckInSettingsType!

  """Update an existing tee time"""
  updateTeeTime(id: ID!, input: UpdateTeeTimeInput!): TeeTimeType!

  """Update a tee time block"""
  updateTeeTimeBlock(id: ID!, input: UpdateBlockInput!): BlockMutationResponse!

  """Update players for an existing tee time (with proper capacity check)"""
  updateTeeTimePlayers(id: ID!, players: [TeeTimePlayerInput!]!): TeeTimeType!

  """Update a time period"""
  updateTimePeriod(id: ID!, input: UpdateTimePeriodInput!): TimePeriodMutationResponse!

  """Update a waitlist entry"""
  updateWaitlistEntry(id: ID!, input: UpdateWaitlistEntryInput!): WaitlistMutationResponse!

  """Create or update auto-pay settings"""
  upsertAutoPaySetting(input: AutoPaySettingInput!): AutoPaySetting!

  """Create or update a POS template"""
  upsertPOSTemplate(id: ID, input: POSTemplateInput!): UpsertTemplateMutationResponse!

  """Verify a sub-account PIN"""
  verifySubAccountPin(input: VerifyPinInput!): PinVerificationResult!

  """Void a credit note"""
  voidCreditNote(id: ID!, input: VoidCreditNoteInput!): CreditNoteGraphQLType!

  """Void an invoice"""
  voidInvoice(id: ID!, input: VoidInvoiceInput!): InvoiceType!
}

"""Which nine holes (front or back) for crossover mode"""
enum NineType {
  BACK
  FRONT
}

input OpenDayInput {
  businessDate: DateTime!
}

input OpenShiftInput {
  cashDrawerId: ID!

  """JSON string of denomination counts"""
  denominations: String
  openingFloat: Float!
}

"""
Type of operation this equipment category belongs to (Golf, Facility, Spa, Event)
"""
enum OperationType {
  EVENT
  FACILITY
  GOLF
  SPA
}

type OutletGridConfig {
  categoryStyle: CategoryDisplayStyle!
  gridColumns: Int!
  gridRows: Int!
  id: ID!
  outletId: ID!
  quickKeysCount: Int!
  quickKeysEnabled: Boolean!
  quickKeysPosition: QuickKeysPosition!
  showAllCategory: Boolean!
  showImages: Boolean!
  showPrices: Boolean!
  tileSize: TileSize!
}

type OutletProductConfig {
  buttonColor: String
  displayName: String
  gridPosition: JSON
  id: ID!
  isQuickKey: Boolean!
  isVisible: Boolean!
  outletId: ID!
  product: Product
  productId: ID!
  quickKeyPosition: Int
  sortPriority: Int
  visibilityRules: JSON!
}

type OutletProductPanel {
  gridConfig: OutletGridConfig!
  quickKeys: [Product!]!
  suggestionConfig: SmartSuggestionConfig
  suggestions: [Product!]!
}

type POSButtonRegistryGraphQLType {
  clubId: String!
  registry: JSON!
  updatedAt: DateTime!
}

type POSButtonStateGraphQLType {
  buttonId: String!
  enabled: Boolean!
  requiresApproval: Boolean!
  visible: Boolean!
}

input POSConfigInput {
  isConnected: Boolean
  provider: String
  terminalId: String
}

type POSConfigType {
  isConnected: Boolean!
  provider: String
  terminalId: String
}

type POSOutletGraphQLType {
  clubId: String!
  createdAt: DateTime!
  customConfig: JSON!
  id: ID!
  isActive: Boolean!
  name: String!
  outletType: String!
  roleConfigs: [POSOutletRoleConfigGraphQLType!]
  template: POSTemplateGraphQLType
  templateId: String
  updatedAt: DateTime!
}

type POSOutletRoleConfigGraphQLType {
  buttonOverrides: JSON!
  createdAt: DateTime!
  id: ID!
  outletId: String!
  role: String!
  updatedAt: DateTime!
}

type POSResolvedConfigGraphQLType {
  actionBarConfig: JSON!
  buttonStates: [POSButtonStateGraphQLType!]!
  outlet: POSOutletGraphQLType!
  template: POSTemplateGraphQLType
  toolbarConfig: JSON!
}

input POSRoleOverridesInput {
  disabled: [String!]
  hidden: [String!]
  requireApproval: [String!]
  role: String!
}

type POSTemplateGraphQLType {
  actionBarConfig: JSON!
  clubId: String!
  createdAt: DateTime!
  description: String
  id: ID!
  isDefault: Boolean!
  name: String!
  outletType: String!
  outlets: [POSOutletGraphQLType!]
  toolbarConfig: JSON!
  updatedAt: DateTime!
}

input POSTemplateInput {
  actionBarConfig: JSON!
  description: String
  isDefault: Boolean! = false
  name: String!
  outletType: String!
  toolbarConfig: JSON!
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

input PayLineItemsInput {
  lineItemIds: [ID!]!
  paymentMethodId: ID!
  reference: String
}

type PayLineItemsResultType {
  error: String
  paidCount: Int!
  success: Boolean!
  totalPaid: Float!
  transactionId: String
}

input PaymentAllocationInput {
  amount: Float!
  invoiceId: ID!
}

type PaymentAllocationSummaryType {
  amount: String!
  id: ID!
  payment: PaymentSummaryType!
}

"""Payment method options"""
enum PaymentMethod {
  BANK_TRANSFER
  CASH
  CHECK
  CREDIT_CARD
  DIRECT_DEBIT
  MOBILE_PAYMENT
  OTHER
}

"""Type of payment method"""
enum PaymentMethodTypeEnum {
  ACCOUNT
  CARD
  CASH
  CUSTOM
  TRANSFER
}

"""Payment status for player check-in"""
enum PaymentStatus {
  NO_CHARGES
  PARTIAL
  PREPAID
  UNPAID
}

type PaymentSummaryType {
  amount: String!
  id: ID!
  method: PaymentMethod!
  paymentDate: DateTime!
  receiptNumber: String!
}

type PaymentTransactionType {
  allocatedAt: DateTime
  allocatedToRevenue: Boolean!
  amount: Float!
  clubId: ID!
  createdAt: DateTime!
  id: ID!
  lineItemPayments: [LineItemPaymentType!]
  paidAt: DateTime!
  paidBy: String!
  paymentMethodId: ID!
  paymentMethodName: String
  reference: String
  refundAmount: Float
  refundReason: String
  refundedAt: DateTime
  refundedBy: String
  status: TransactionStatus!
  teeTimeId: ID
  transactionNumber: String!
  updatedAt: DateTime!
  voidReason: String
  voidedAt: DateTime
  voidedBy: String
}

type PaymentType {
  accountLast4: String
  amount: String!
  bankName: String
  createdAt: DateTime!
  id: ID!
  member: MemberSummaryBillingType
  method: PaymentMethod!
  notes: String
  paymentDate: DateTime!
  receiptNumber: String!
  referenceNumber: String
}

type PaymentTypeEdge {
  cursor: String!
  node: PaymentType!
}

type PinVerificationResult {
  message: String
  remainingAttempts: Float
  success: Boolean!
}

"""Golf play format (18 holes or cross-tee)"""
enum PlayFormat {
  CROSS_TEE
  EIGHTEEN_HOLE
}

type PlayerCheckInResultType {
  checkedIn: Boolean!
  error: String
  playerId: ID!
}

type PlayerDependentType {
  firstName: String!
  id: ID!
  lastName: String!

  """Parent member UUID"""
  memberId: ID
  relationship: String!
}

type PlayerMemberType {
  firstName: String!
  id: ID!
  lastName: String!
  memberId: String!
}

type PlayerPaymentInfoType {
  balanceDue: Float!
  grandTotal: Float!
  isSettled: Boolean!
  lineItems: [BookingLineItemType!]!
  memberNumber: String
  paidOnline: Float!
  playerId: ID!
  playerName: String!
  playerType: CheckInPlayerType!
  settledAt: DateTime
  settledBy: String
  settledVia: String
  subtotal: Float!
  totalTax: Float!
}

input PlayerPaymentInput {
  amount: Float!

  """Specific line item IDs to mark as paid"""
  lineItemIds: [ID!]
  playerId: ID!
}

type PlayerSettlementResultType {
  amountPaid: Float!
  error: String
  playerId: ID!
  success: Boolean!
}

"""Type of player in a tee time"""
enum PlayerType {
  DEPENDENT
  GUEST
  MEMBER
  WALK_UP
}

"""Status of a player position in a tee time slot"""
enum PositionStatus {
  AVAILABLE
  BLOCKED
  BOOKED
}

type PriceModifierType {
  amount: Float!
  isPercentage: Boolean!
  label: String!
}

"""Print output options for starter ticket"""
enum PrintOption {
  COMBINED
  NONE
  RECEIPT
  TICKET
}

input PrintTicketInput {
  copies: Float = 1
  ticketId: ID!
}

type ProShopCategoryType {
  defaultTaxRate: Float!
  defaultTaxType: TaxType!
  description: String
  id: ID!
  isActive: Boolean!
  name: String!
  productCount: Int
  sortOrder: Int!
}

input ProShopConfigInput {
  allowAddAtCheckIn: Boolean
  quickAddProductIds: [ID!]
  showQuickAddItems: Boolean
}

type ProShopConfigType {
  allowAddAtCheckIn: Boolean!
  quickAddProductIds: [ID!]!
  showQuickAddItems: Boolean!
}

type ProShopProductConnectionType {
  hasMore: Boolean!
  items: [ProShopProductType!]!
  limit: Int!
  page: Int!
  total: Int!
}

input ProShopProductFilterInput {
  categoryId: ID
  isActive: Boolean
  isQuickAdd: Boolean
  limit: Int = 20
  page: Int = 1
  search: String
}

type ProShopProductType {
  category: ProShopCategoryType
  categoryId: ID!
  description: String
  effectiveTaxRate: Float!
  effectiveTaxType: TaxType!
  id: ID!
  isActive: Boolean!
  isQuickAdd: Boolean!
  name: String!
  price: Float!
  sku: String
  taxRate: Float!
  taxType: TaxType!
  useCategoryDefaults: Boolean!
  variants: [ProShopVariantType!]!
}

type ProShopVariantType {
  finalPrice: Float!
  id: ID!
  name: String!
  priceAdjustment: Float!
  sku: String
}

input ProcessAutoPayInput {
  amount: Float!
  invoiceId: String!
  paymentMethodId: ID!
}

input ProcessSettlementInput {
  notes: String
  paymentMethodId: ID!
  payments: [PlayerPaymentInput!]!
  reference: String
  teeTimeId: ID!
}

type Product {
  basePrice: Float!
  bufferMinutes: Int
  category: ProductCategory!
  costPrice: Float
  description: String
  durationMinutes: Int
  hasModifiers: Boolean!
  hasVariants: Boolean!
  id: ID!
  imageUrl: String
  isActive: Boolean!
  isInStock: Boolean!
  lowStockThreshold: Int
  modifierGroups: [ModifierGroup!]!
  name: String!
  productType: ProductType!
  sku: String
  sortPriority: Int!
  stockQuantity: Int
  taxRate: Float!
  thumbnailUrl: String
  trackInventory: Boolean!
  variants: [ProductVariant!]!
}

type ProductCategory {
  children: [ProductCategory!]
  color: String
  description: String
  iconName: String
  id: ID!
  isActive: Boolean!
  name: String!
  parentId: ID
  productCount: Int
  sortOrder: Int!
}

type ProductConnection {
  edges: [ProductEdge!]!
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  totalCount: Int!
}

type ProductEdge {
  cursor: String!
  node: Product!
}

input ProductFilterInput {
  after: String
  categoryId: ID
  first: Int
  isActive: Boolean
  productType: ProductType
  search: String
  trackInventory: Boolean
}

enum ProductType {
  COMPOSITE
  SERVICE
  SIMPLE
  VARIABLE
}

type ProductVariant {
  attributes: JSON
  id: ID!
  imageUrl: String
  isActive: Boolean!
  name: String!
  priceAdjustment: Float!
  sku: String
  sortOrder: Int!
  stockQuantity: Int
}

"""Proration calculation method"""
enum ProrationMethod {
  DAILY
  MONTHLY
  NONE
}

"""Preview of proration calculation"""
type ProrationPreview {
  """Total days in the billing period"""
  daysInPeriod: Int!

  """Number of days being prorated"""
  daysProrated: Int!

  """Human-readable description of the proration"""
  description: String!

  """Prorated amount in cents"""
  proratedAmount: Float!

  """Proration factor (0-1)"""
  prorationFactor: Float!
}

input ProrationPreviewInput {
  """Effective date for the prorated period"""
  effectiveDate: DateTime!

  """Full period amount before proration"""
  fullPeriodAmount: Float!
  memberId: ID!
}

type Query {
  """Get all active discounts for POS use"""
  activeDiscounts: [DiscountGraphQLType!]!

  """Get active schedule for a course and date"""
  activeSchedule(courseId: ID!, date: DateTime!): GolfCourseScheduleType

  """Get a single membership application by ID"""
  application(id: ID!): MembershipApplicationType!

  """Get application statistics"""
  applicationStats: ApplicationStatsType!

  """Get paginated list of membership applications"""
  applications(after: String, first: Int = 10, search: String, skip: Int, status: ApplicationStatus): ApplicationConnection!

  """Get AR aging report with buckets and member details"""
  arAgingReport(filter: String, limit: Float = 20, page: Float = 1): ArAgingReportType!

  """Calculate totals for multiple players (for batch payment)"""
  batchTotal(playerIds: [ID!]!): BatchTotalType!

  """Get billing statistics for the current month"""
  billingStats: BillingStatsType!

  """Get a single booking by ID"""
  booking(id: ID!): BookingType!

  """Get list of staff for booking"""
  bookingStaff(filter: StaffFilterInput): [StaffType!]!

  """Get booking statistics for today"""
  bookingStats: BookingStatsType!

  """Get paginated list of bookings"""
  bookings(after: String, bookingType: BookingTypeEnum, endDate: String, facilityId: ID, first: Int = 20, memberId: ID, search: String, skip: Int, staffId: ID, startDate: String, statuses: [BookingStatus!]): BookingConnection!

  """Get calendar data for a specific day"""
  calendarDay(date: String!, facilityId: ID, resourceIds: [ID!], statuses: [BookingStatus!]): CalendarDayType!

  """Get cart draft for a tee time"""
  cartDraft(teeTimeId: ID!): CartDraftType

  """Get a single cash drawer by ID"""
  cashDrawer(id: ID!): CashDrawerGraphQLType

  """Get a shift by ID"""
  cashDrawerShift(shiftId: ID!): CashDrawerShiftGraphQLType

  """Get all cash drawers for the current club"""
  cashDrawers(activeOnly: Boolean = true): [CashDrawerGraphQLType!]!

  """Get available charge types"""
  chargeTypes: [ChargeTypeType!]!

  """Get check-in audit history"""
  checkInHistory(filter: CheckInHistoryFilterInput): [CheckInAuditEntryType!]!

  """Get a single payment method by ID"""
  checkInPaymentMethod(id: ID!): CheckInPaymentMethodType

  """Get all payment methods for check-in"""
  checkInPaymentMethods: [CheckInPaymentMethodType!]!

  """Check if a charge is allowed for a member based on their credit limit"""
  checkMemberCredit(input: CheckCreditInput!): CreditCheckResultType!

  """Check if a sub-account can make a transaction"""
  checkSubAccountLimit(input: CheckLimitInput!): SubAccountLimitCheck!

  """Get club-wide billing configuration settings"""
  clubBillingSettings: ClubBillingSettingsType!

  """Get club golf settings including cart, rental, and caddy policies"""
  clubGolfSettings: ClubGolfSettingsType

  """Get schedules for a course"""
  courseSchedules(courseId: ID!): [GolfCourseScheduleType!]!

  """Get all golf courses"""
  courses: [GolfCourseType!]!

  """Get a single credit note by ID"""
  creditNote(id: ID!): CreditNoteGraphQLType!

  """Get paginated list of credit notes"""
  creditNotes(after: String, endDate: DateTime, first: Int = 10, memberId: ID, skip: Int, startDate: DateTime, status: CreditNoteStatus): CreditNoteConnection!

  """Get or create current period spend for a member and requirement"""
  currentMemberSpend(memberId: ID!, requirementId: ID!): MemberMinimumSpend!

  """Get the current open shift for a drawer"""
  currentShift(cashDrawerId: ID!): CashDrawerShiftGraphQLType

  """Get daily check-in report for a course"""
  dailyCheckInReport(input: DailyReportInput!): DailyCheckInReportType!

  """Get all interests for a dependent"""
  dependentInterests(dependentId: ID!): [DependentInterestType!]!

  """Get a single discount by ID"""
  discount(id: ID!): DiscountGraphQLType

  """Find a discount by its code"""
  discountByCode(code: String!): DiscountGraphQLType

  """Get all discounts for the current club with filtering and pagination"""
  discounts(after: String, first: Int = 10, isActive: Boolean, scope: DiscountScope, search: String, skip: Int, sortBy: String = "name", sortOrder: String = "asc", type: DiscountType): DiscountConnection!
  equipment(filter: EquipmentFilterInput): [Equipment!]!
  equipmentAvailability(input: EquipmentAvailabilityInput!): [Equipment!]!
  equipmentCategories(filter: EquipmentCategoryFilterInput): [EquipmentCategory!]!
  equipmentCategory(id: ID!): EquipmentCategory
  equipmentItem(id: ID!): Equipment

  """Get list of facilities"""
  facilities(filter: FacilityFilterInput): [FacilityType!]!

  """Get check-in info for all players in a tee time"""
  flightCheckInInfo(teeTimeId: ID!): FlightCheckInInfoType!

  """Get payment summary for a flight"""
  flightPaymentSummary(teeTimeId: ID!): FlightPaymentSummaryType!

  """Generate a member statement for a date range"""
  generateStatement(input: GenerateStatementInput!): StatementType!

  """Generate a tee ticket for a tee time"""
  generateTeeTicket(teeTimeId: ID!): TeeTicketType

  """
  Get the effective schedule for a specific date (with season/special day overrides applied)
  """
  getEffectiveScheduleForDate(courseId: ID!, date: DateTime!): EffectiveScheduleType!

  """
  Get schedule configuration for a course. Creates default config if autoCreate is true.
  """
  getScheduleConfig(autoCreate: Boolean = false, courseId: ID!): GolfScheduleConfigType

  """Get complete golf check-in settings for the current club"""
  golfCheckInSettings: CheckInSettingsType!

  """Get rate configurations for a course"""
  golfRates(activeOnly: Boolean, courseId: ID!): [RateConfigType!]!

  """Get a single group booking"""
  groupBooking(id: ID!): GolfGroupBookingType!

  """Get group bookings"""
  groupBookings(courseId: ID, endDate: DateTime, startDate: DateTime, status: GroupBookingStatus): [GolfGroupBookingType!]!

  """Check if a tee time has a cart draft"""
  hasDraft(teeTimeId: ID!): Boolean!

  """Get all interest categories for the club"""
  interestCategories(
    """Filter by active status"""
    isActive: Boolean
  ): [InterestCategoryType!]!

  """Get a single interest category by ID"""
  interestCategory(id: ID!): InterestCategoryType!

  """Get a single invoice by ID"""
  invoice(id: ID!): InvoiceType!

  """Get auto-pay attempts for an invoice"""
  invoiceAutoPayAttempts(invoiceId: ID!): [AutoPayAttempt!]!

  """Get paginated list of invoices"""
  invoices(after: String, endDate: DateTime, first: Int = 10, memberId: ID, search: String, skip: Int, sortBy: String = "invoiceDate", sortOrder: String = "desc", startDate: DateTime, status: InvoiceStatus): InvoiceConnection!

  """Check if all players in a tee time are settled"""
  isTeeTimeFullySettled(teeTimeId: ID!): Boolean!

  """Get discounts applied to a line item"""
  lineItemDiscounts(lineItemId: ID!): [AppliedDiscountType!]!
  lookupCategories(filter: LookupCategoryFilterInput): [LookupCategory!]!
  lookupCategory(code: String!): LookupCategory
  lookupValue(id: ID!): LookupValue
  lookupValues(categoryCode: String!, includeInactive: Boolean): [LookupValue!]!

  """Get lotteries"""
  lotteries(courseId: ID, endDate: DateTime, startDate: DateTime, status: LotteryStatus): [GolfLotteryType!]!

  """Get a single lottery"""
  lottery(id: ID!): GolfLotteryType!

  """Get a single member by ID"""
  member(id: ID!): MemberType!

  """Get member addresses"""
  memberAddresses(memberId: ID!): [MemberAddressType!]!

  """Get auto-pay attempt history for a member"""
  memberAutoPayHistory(input: GetAutoPayHistoryInput!): [AutoPayAttempt!]!

  """Get auto-pay settings for a member"""
  memberAutoPaySetting(memberId: ID!): AutoPaySetting

  """Get billing profile for a specific member"""
  memberBillingProfile(memberId: ID!): MemberBillingProfileType

  """Get communication preferences for a member"""
  memberCommunicationPrefs(memberId: ID!): MemberCommunicationPrefsType!

  """Get credit limit override history for a member"""
  memberCreditOverrideHistory(limit: Int = 10, memberId: ID!): [CreditLimitOverrideType!]!

  """Get active credit limit overrides for a member"""
  memberCreditOverrides(memberId: ID!): [CreditLimitOverrideType!]!

  """Get credit settings for a member"""
  memberCreditSettings(memberId: ID!): CreditSettingsType

  """Get credit status for a member (for display in UI)"""
  memberCreditStatus(memberId: ID!): CreditStatusType

  """Get member dependents"""
  memberDependents(memberId: ID!): [DependentType!]!

  """Get all interests for a member"""
  memberInterests(memberId: ID!): [MemberInterestType!]!

  """Get a member minimum spend record by ID"""
  memberMinimumSpend(id: ID!): MemberMinimumSpend

  """Get member minimum spend records"""
  memberMinimumSpends(input: GetMemberSpendsInput!): [MemberMinimumSpend!]!

  """Get all stored payment methods for a member"""
  memberPaymentMethods(activeOnly: Boolean = true, memberId: ID!): [StoredPaymentMethod!]!

  """Get member statistics"""
  memberStats: MemberStatsType!

  """Get sub-accounts for a member"""
  memberSubAccounts(activeOnly: Boolean = true, memberId: ID!): [SubAccount!]!

  """Get transaction history for a member"""
  memberTransactions(memberId: ID!): MemberTransactionsType!

  """Get paginated list of members"""
  members(after: String, first: Int = 10, householdId: ID, membershipTypeId: ID, search: String, skip: Int, sortBy: String = "createdAt", sortOrder: String = "desc", status: MemberStatus): MemberConnection!

  """Get members approaching or exceeding their credit limits"""
  membersAtCreditRisk: [MemberAtRiskType!]!

  """Get all membership types"""
  membershipTypes: [MembershipTypeType!]!

  """Get a minimum spend requirement by ID"""
  minimumSpendRequirement(id: ID!): MinimumSpendRequirement

  """Get all minimum spend requirements for the club"""
  minimumSpendRequirements(activeOnly: Boolean = true): [MinimumSpendRequirement!]!
  modifierGroups: [ModifierGroup!]!

  """Get current member's invoices"""
  myInvoices(after: String, endDate: DateTime, first: Int = 10, memberId: ID, search: String, skip: Int, sortBy: String = "invoiceDate", sortOrder: String = "desc", startDate: DateTime, status: InvoiceStatus): InvoiceConnection!

  """Get current user lottery requests"""
  myLotteryRequests: [GolfLotteryRequestType!]!

  """Get the current user's member profile"""
  myMember: MemberType

  """Get current user waitlist entries"""
  myWaitlistEntries: [GolfWaitlistType!]!

  """Get open lotteries for member portal"""
  openLotteries: [GolfLotteryType!]!
  outletGridConfig(outletId: ID!): OutletGridConfig
  outletProductConfigs(outletId: ID!): [OutletProductConfig!]!
  outletProductPanel(outletId: ID!): OutletProductPanel!

  """Get a single stored payment method"""
  paymentMethod(id: ID!): StoredPaymentMethod

  """Get detailed payment info for a single player"""
  playerPaymentInfo(playerId: ID!): PlayerPaymentInfoType!

  """Get the button registry for the current club"""
  posButtonRegistry: POSButtonRegistryGraphQLType!

  """Get resolved POS configuration for an outlet and user role"""
  posConfig(outletId: ID!, userPermissions: [String!], userRole: String!): POSResolvedConfigGraphQLType!

  """Get a single POS outlet by ID"""
  posOutlet(id: ID!): POSOutletGraphQLType

  """Get all POS outlets for the current club"""
  posOutlets: [POSOutletGraphQLType!]!

  """Get a single POS template by ID"""
  posTemplate(id: ID!): POSTemplateGraphQLType

  """Get all POS templates for the current club"""
  posTemplates: [POSTemplateGraphQLType!]!

  """Preview FIFO allocation for a payment amount"""
  previewFifoAllocation(accountId: ID!, accountType: String!, paymentAmount: Float!): FifoAllocationPreview!

  """Preview late fee calculation for an overdue invoice"""
  previewLateFee(input: LateFeePreviewInput!): LateFeePreview!

  """
  Preview the next billing period dates for a member based on their configuration
  """
  previewNextBillingPeriod(memberId: ID!): BillingPeriodPreview!

  """Preview prorated amount for a member joining mid-cycle"""
  previewProration(input: ProrationPreviewInput!): ProrationPreview!

  """Get all pro shop categories for the current club"""
  proShopCategories: [ProShopCategoryType!]!

  """Get a single pro shop category by ID"""
  proShopCategory(id: ID!): ProShopCategoryType

  """Get a single pro shop product by ID"""
  proShopProduct(id: ID!): ProShopProductType

  """Get pro shop products with filtering and pagination"""
  proShopProducts(filter: ProShopProductFilterInput): ProShopProductConnectionType!
  product(id: ID!): Product

  """Get all product categories"""
  productCategories(includeInactive: Boolean): [ProductCategory!]!
  productCategory(id: ID!): ProductCategory

  """Get products with filtering and pagination"""
  products(filter: ProductFilterInput): ProductConnection!

  """Get products marked as quick add for check-in"""
  quickAddProducts: [ProShopProductType!]!
  quickKeyProducts(outletId: ID!): [Product!]!

  """Get a single rate configuration by ID"""
  rateConfig(id: ID!): RateConfigType!

  """Get HTML template for a receipt"""
  receiptHTML(playerId: ID!, teeTimeId: ID!): String!

  """Search AR accounts (Members + City Ledger)"""
  searchArAccounts(accountTypes: [String!], limit: Float = 10, search: String!): [ArAccountSearchResult!]!

  """Search for caddies by name or caddy number"""
  searchCaddies(courseId: ID, search: String): [CaddyType!]!

  """Get list of services"""
  services(filter: ServiceFilterInput): [ServiceType!]!

  """Get a settlement by ID"""
  settlement(id: ID!): DailySettlementGraphQLType

  """Get or create a settlement for a specific date"""
  settlementByDate(date: DateTime!): DailySettlementGraphQLType!

  """Get exceptions for a settlement"""
  settlementExceptions(pendingOnly: Boolean = false, settlementId: ID!): [SettlementExceptionGraphQLType!]!

  """Get settlement summary"""
  settlementSummary(settlementId: ID!): SettlementSummaryGraphQLType!

  """Get settlements for a date range"""
  settlements(input: GetSettlementsInput!): [DailySettlementGraphQLType!]!

  """Get shift history for a drawer"""
  shiftHistory(cashDrawerId: ID!, limit: Int = 30): [CashDrawerShiftGraphQLType!]!

  """Get movements for a shift"""
  shiftMovements(shiftId: ID!, type: CashMovementType): [CashMovementGraphQLType!]!

  """Get summary for a shift"""
  shiftSummary(shiftId: ID!): ShiftSummaryGraphQLType!

  """Get cart for a specific player/slot"""
  slotCart(playerId: ID!): SlotCartType
  smartSuggestionConfig(outletId: ID!): SmartSuggestionConfig
  smartSuggestions(outletId: ID!): [Product!]!

  """Get starter ticket by ID"""
  starterTicket(ticketId: ID!): StarterTicketResponseType

  """Get starter ticket for a tee time"""
  starterTicketByTeeTime(teeTimeId: ID!): StarterTicketResponseType

  """Get a sub-account by ID"""
  subAccount(id: ID!): SubAccount

  """Get transactions for sub-accounts"""
  subAccountTransactions(input: GetTransactionsInput!): [SubAccountTransaction!]!

  """Get all sub-accounts for the club"""
  subAccounts(status: SubAccountStatus): [SubAccount!]!

  """Get tee sheet for a course and date"""
  teeSheet(courseId: ID!, date: DateTime!): [TeeSheetSlotType!]!

  """Get a single tee time by ID"""
  teeTime(id: ID!): TeeTimeType!

  """Get tee time blocks for a course"""
  teeTimeBlocks(blockType: BlockType, courseId: ID!, endDate: DateTime, startDate: DateTime): [TeeTimeBlockType!]!

  """Get all carts for a tee time with context info"""
  teeTimeCarts(teeTimeId: ID!): TeeTimeCartsType!

  """Get paginated list of tee times"""
  teeTimes(courseId: ID, endDate: DateTime, first: Int = 20, memberId: ID, skip: Int, startDate: DateTime, status: TeeTimeStatus): TeeTimeConnection!

  """Get all tee time IDs with drafts for a specific date"""
  teeTimesWithDrafts(date: DateTime!): [ID!]!

  """Get HTML template for a starter ticket"""
  ticketHTML(teeTimeId: ID!): String!

  """Get today's settlement for the current club"""
  todaySettlement: DailySettlementGraphQLType

  """Get discounts applied to a transaction"""
  transactionDiscounts(transactionId: ID!): [AppliedDiscountType!]!

  """Get payment transaction history for a tee time"""
  transactionHistory(teeTimeId: ID!): [PaymentTransactionType!]!

  """Validate if a discount can be applied"""
  validateDiscount(input: ValidateDiscountInput!): DiscountValidationResultType!

  """Validate a tee ticket by barcode"""
  validateTeeTicket(barcode: String!): TeeTicketValidationResult!

  """Validate a ticket by QR code data"""
  validateTicket(qrCodeData: String!): TicketValidationResultType!

  """Get waitlist entries"""
  waitlist(date: String, facilityId: ID, first: Int = 20, serviceId: ID, skip: Int): WaitlistConnection!

  """Get waitlist entries"""
  waitlistEntries(courseId: ID, endDate: DateTime, startDate: DateTime, status: GolfWaitlistStatus): [GolfWaitlistType!]!

  """Get a single waitlist entry"""
  waitlistEntry(id: ID!): GolfWaitlistType!

  """Get waitlist entries for a specific date/course"""
  waitlistForDate(courseId: ID!, date: DateTime!): [GolfWaitlistType!]!

  """
  Get week view occupancy data showing player positions for each time slot
  """
  weekViewOccupancy(input: WeekViewOccupancyInput!): WeekViewOccupancyResponse!
}

enum QuickKeysPosition {
  LEFT
  TOP
}

type RateConfigMutationResponse {
  message: String
  rateConfig: RateConfigType
  success: Boolean!
}

type RateConfigType {
  caddyRates: [CaddyRateType!]!
  cartRates: [CartRateType!]!
  courseId: ID!
  createdAt: DateTime!
  description: String
  effectiveFrom: DateTime!
  effectiveTo: DateTime
  greenFeeRates: [GreenFeeRateType!]!
  id: ID!
  isActive: Boolean!
  name: String!
  updatedAt: DateTime!
}

input RecordCashCountInput {
  actualCash: Float!
  settlementId: ID!
}

input RecordMovementInput {
  amount: Float!
  description: String
  reason: String
  reference: String
  shiftId: ID!
  transactionId: ID
  type: CashMovementType!
}

input RecordSpendInput {
  amount: Float!
  category: String
  memberId: String!
  requirementId: String!
}

input RecordTransactionInput {
  amount: Float!
  category: SubAccountPermission!
  description: String!
  lineItemId: String
  locationName: String
  notes: String
  paymentTransactionId: String
  subAccountId: String!
  teeTimeId: String
}

type ReinstatedMemberType {
  clearedDate: DateTime!
  id: ID!
  name: String!
  previousBalance: String!
  receiptId: ID!
  receiptNumber: String!
}

input RemoveLineItemInput {
  lineItemId: ID!
}

type RemoveLineItemResultType {
  error: String
  removedItem: SlotLineItemType
  success: Boolean!
}

type RemovePaymentMethodResult {
  error: String
  success: Boolean!
}

"""Rental club policy for golf bookings"""
enum RentalPolicy {
  OPTIONAL
  REQUIRED
}

"""Status of rental item (cart/caddy) for a player"""
enum RentalStatus {
  ASSIGNED
  NONE
  PAID
  REQUESTED
  RETURNED
}

input ReopenSettlementInput {
  reason: String!
  settlementId: ID!
}

input RescheduleBookingInput {
  id: ID!
  newResourceId: ID
  newStartTime: String!
}

input ResolveExceptionInput {
  exceptionId: ID!
  resolution: ExceptionResolution!
  resolutionNote: String
}

input ResolveShortfallInput {
  action: ShortfallAction!
  memberSpendId: String!
  note: String
}

type ResourceType {
  facility: FacilityType
  facilityId: ID!
  id: ID!
  isActive: Boolean!
  name: String!
}

enum ResourceTypeEnum {
  COURT
  POOL
  ROOM
  SPA
  STUDIO
}

input ReturnEquipmentInput {
  assignmentId: ID!
  conditionAtReturn: EquipmentCondition
  notes: String
}

input RoleRulesInput {
  allowedRoles: [String!]
  deniedRoles: [String!]
}

input SaveCartDraftInput {
  """JSON stringified draft data"""
  draftData: String!
  teeTimeId: ID!
}

type ScheduleConfigMutationResponse {
  config: GolfScheduleConfigType
  message: String
  success: Boolean!
}

type ScheduleMutationResponse {
  message: String
  schedule: GolfCourseScheduleType
  success: Boolean!
}

type SeasonMutationResponse {
  message: String
  season: GolfSeasonType
  success: Boolean!
}

input SendWaitlistOfferInput {
  entryId: ID!
  expiresInHours: Int = 24
}

input ServiceFilterInput {
  category: String
  isActive: Boolean
}

type ServiceResponseType {
  error: String
  service: ExtendedServiceType
  success: Boolean!
}

type ServiceType {
  basePrice: Float!
  category: String!
  description: String
  durationMinutes: Int!
  id: ID!
  isActive: Boolean!
  name: String!
}

input ServiceVariationInput {
  id: String
  name: String!
  priceModifier: Float!
  priceType: String! = "add"
}

type ServiceVariationType {
  id: ID!
  name: String!
  priceModifier: Float!
  priceType: String!
}

"""Input for setting dependent interests"""
input SetDependentInterestsInput {
  dependentId: ID!
  interests: [DependentInterestInput!]!
}

"""Input for setting member interests"""
input SetMemberInterestsInput {
  interests: [MemberInterestInput!]!
  memberId: ID!
}

type SetRoleOverridesMutationResponse {
  message: String
  roleConfig: POSOutletRoleConfigGraphQLType
  success: Boolean!
}

input SettleAllPlayersInput {
  paymentMethodId: ID!
  reference: String
  teeTimeId: ID!
}

type SettlementExceptionGraphQLType {
  amount: Float
  createdAt: DateTime!
  description: String!
  id: ID!
  lineItemId: ID
  resolution: ExceptionResolution!
  resolutionNote: String
  resolvedAt: DateTime
  resolvedBy: ID
  settlementId: ID!
  severity: ExceptionSeverity!
  shiftId: ID
  transactionId: ID
  type: ExceptionType!
  updatedAt: DateTime!
}

type SettlementResultType {
  error: String
  players: [PlayerSettlementResultType!]!
  settledAt: DateTime!
  settledBy: String!
  success: Boolean!
  transactionId: String
}

"""Status of a daily settlement"""
enum SettlementStatus {
  CLOSED
  IN_REVIEW
  OPEN
  REOPENED
}

type SettlementSummaryGraphQLType {
  actualCash: Float
  businessDate: DateTime!
  cashVariance: Float
  exceptionCount: Int!
  expectedCash: Float!
  settlementId: ID!
  status: SettlementStatus!
  totalCard: Float!
  totalCash: Float!
  totalGrossSales: Float!
  totalMemberAccount: Float!
  totalNetSales: Float!
  unresolvedExceptionCount: Int!
}

type ShiftSummaryGraphQLType {
  actualCash: Float
  closedAt: DateTime
  closedBy: ID
  closingCount: Float
  expectedCash: Float!
  movementCount: Float!
  openedAt: DateTime!
  openedBy: ID!
  openingFloat: Float!
  shiftId: ID!
  status: CashDrawerStatus!
  totalDrops: Float!
  totalPaidIn: Float!
  totalPaidOut: Float!
  totalRefunds: Float!
  totalSales: Float!
  variance: Float
}

"""Action to take when member has a shortfall"""
enum ShortfallAction {
  CARRY_FORWARD
  CHARGE_DIFFERENCE
  CREDIT_BALANCE
  WAIVE
}

type SlotCartType {
  balanceDue: Float!
  checkedInAt: DateTime
  grandTotal: Float!
  isCheckedIn: Boolean!
  isSettled: Boolean!
  lineItems: [SlotLineItemType!]!
  memberId: ID
  memberNumber: String
  paidAmount: Float!
  playerId: ID!
  playerName: String!
  playerType: String!
  subtotal: Float!
  taxTotal: Float!
  transferredInItems: [TransferredItemType!]!
  transferredOutItems: [TransferredItemType!]!
}

type SlotCheckInResultType {
  checkedInAt: DateTime
  error: String
  playerId: ID!
}

type SlotLineItemType {
  baseAmount: Float!
  description: String!
  id: ID!
  isPaid: Boolean!
  isTransferred: Boolean!
  paidAt: DateTime
  paymentMethod: String
  quantity: Int!
  taxAmount: Float!
  taxRate: Float!
  taxType: String!
  totalAmount: Float!
  transferredFromPlayerName: String
  type: String!
}

type SlotPaymentResultType {
  amountPaid: Float!
  isSettled: Boolean!
  newBalance: Float!
  playerId: ID!
}

type SmartSuggestionConfig {
  enabled: Boolean!
  id: ID!
  outletId: ID!
  position: SuggestionPosition!
  refreshIntervalMinutes: Int!
  salesVelocityWeight: Int!
  staffHistoryWeight: Int!
  suggestionCount: Int!
  timeOfDayWeight: Int!
}

type SpecialDayMutationResponse {
  message: String
  specialDay: GolfSpecialDayType
  success: Boolean!
}

"""Type of special day"""
enum SpecialDayType {
  CLOSED
  CUSTOM
  HOLIDAY
  WEEKEND
}

input StaffCapabilityInput {
  capability: String!
  level: String! = "intermediate"
}

type StaffCapabilityType {
  capability: String!
  level: String!
}

input StaffCertificationInput {
  expiresAt: String!
  id: String
  name: String!
}

type StaffCertificationType {
  expiresAt: DateTime
  id: ID!
  name: String!
  status: String!
}

input StaffFilterInput {
  availableOn: String
  capability: String
  isActive: Boolean
}

type StaffResponseType {
  error: String
  staff: ExtendedStaffType
  success: Boolean!
}

type StaffType {
  capabilities: [String!]
  firstName: String!
  id: ID!
  isActive: Boolean!
  lastName: String!
  photoUrl: String
  role: String
}

"""Tournament start format"""
enum StartFormat {
  SEQUENTIAL
  SHOTGUN
}

input StarterTicketConfigInput {
  autoGenerate: Boolean
  content: TicketContentInput
  defaultPrintOption: PrintOption
  generateOn: TicketGenerateOn
}

type StarterTicketConfigType {
  autoGenerate: Boolean!
  content: TicketContentConfigType!
  defaultPrintOption: PrintOption!
  generateOn: TicketGenerateOn!
}

type StarterTicketPlayerType {
  memberNumber: String
  name: String!
  type: CheckInPlayerType!
}

type StarterTicketResponseType {
  caddyName: String
  cartNumber: String
  course: String!
  generatedAt: DateTime!
  generatedBy: String!
  id: ID!
  players: [StarterTicketPlayerType!]!
  printedAt: DateTime
  qrCodeData: String
  rentalItems: [String!]!
  reprintCount: Int!
  specialRequests: String
  startingHole: Int!
  teeTime: DateTime!
  ticketNumber: String!
}

type StatementType {
  closingBalance: String!
  member: MemberStatementInfoType!
  openingBalance: String!
  periodEnd: DateTime!
  periodStart: DateTime!
  transactions: [MemberTransactionType!]!
}

type StoredPaymentMethod {
  brand: String!
  cardholderName: String
  clubId: String!
  createdAt: DateTime!
  expiryMonth: Int
  expiryYear: Int
  failureCount: Int!
  id: ID!
  isAutoPayEnabled: Boolean!
  isDefault: Boolean!
  last4: String!
  lastFailureReason: String
  lastUsedAt: DateTime
  memberId: String!
  status: StoredPaymentMethodStatus!
  stripeCustomerId: String
  stripePaymentMethodId: String!
  type: StoredPaymentMethodType!
  updatedAt: DateTime!
  verifiedAt: DateTime
}

"""Status of stored payment method"""
enum StoredPaymentMethodStatus {
  ACTIVE
  EXPIRED
  FAILED
  REMOVED
}

"""Type of stored payment method"""
enum StoredPaymentMethodType {
  BANK_ACCOUNT
  CARD
}

type SubAccount {
  clubId: String!
  createdAt: DateTime!
  dailyLimit: Float
  dailySpend: Float!
  email: String
  id: ID!
  lastResetDaily: DateTime!
  lastResetMonthly: DateTime!
  lastResetWeekly: DateTime!
  memberId: String!
  monthlyLimit: Float
  monthlySpend: Float!
  name: String!
  notifyOnLimitReached: Boolean!
  notifyPrimaryOnUse: Boolean!
  perTransactionLimit: Float
  permissions: [SubAccountPermission!]!
  phone: String
  pinAttempts: Int!
  pinLockedUntil: DateTime
  relationship: String!
  status: SubAccountStatus!
  updatedAt: DateTime!
  validFrom: DateTime!
  validUntil: DateTime
  weeklyLimit: Float
  weeklySpend: Float!
}

type SubAccountLimitCheck {
  allowed: Boolean!
  currentDaily: Float!
  currentMonthly: Float!
  currentWeekly: Float!
  dailyLimit: Float
  monthlyLimit: Float
  perTransactionLimit: Float
  reason: String
  weeklyLimit: Float
}

"""Permission categories for sub-accounts"""
enum SubAccountPermission {
  ALL
  EVENTS
  FOOD_BEVERAGE
  GOLF
  RETAIL
  SPA
}

"""Status of a sub-account"""
enum SubAccountStatus {
  ACTIVE
  EXPIRED
  REVOKED
  SUSPENDED
}

type SubAccountTransaction {
  amount: Float!
  category: SubAccountPermission!
  clubId: String!
  createdAt: DateTime!
  description: String!
  id: ID!
  lineItemId: String
  locationName: String
  notes: String
  paymentTransactionId: String
  subAccount: SubAccount
  subAccountId: String!
  teeTimeId: String
  verifiedAt: DateTime!
  verifiedBy: String
}

type Subscription {
  """Subscribe to tee time cancellations"""
  teeTimeCancelled: TeeTimeType!

  """Subscribe to tee time check-ins"""
  teeTimeCheckedIn: TeeTimeType!

  """Subscribe to new tee time creations"""
  teeTimeCreated(courseId: ID): TeeTimeType!

  """Subscribe to tee time updates for a specific course and date"""
  teeTimeUpdated(courseId: ID, date: DateTime): TeeTimeType!
}

enum SuggestionPosition {
  FLOATING
  SIDEBAR
  TOP_ROW
}

input TaxConfigInput {
  defaultRate: Float
  defaultType: TaxType
  overrides: [TaxOverrideInput!]
  showBreakdown: Boolean
  showTypeIndicator: Boolean
  taxLabel: String
}

type TaxConfigType {
  defaultRate: Float!
  defaultType: TaxType!
  overrides: [TaxOverrideType!]!
  showBreakdown: Boolean!
  showTypeIndicator: Boolean!
  taxLabel: String!
}

input TaxOverrideInput {
  itemType: LineItemType!
  rate: Float!
  taxType: TaxType!
}

type TaxOverrideType {
  itemType: LineItemType!
  rate: Float!
  taxType: TaxType!
}

"""Tax calculation type: ADD (on top), INCLUDE (in price), NONE"""
enum TaxType {
  ADD
  INCLUDE
  NONE
}

type TeeSheetBlockInfoType {
  blockType: String!
  id: ID!
  reason: String
}

type TeeSheetSlotType {
  available: Boolean!
  blockInfo: TeeSheetBlockInfoType
  blocked: Boolean!
  booking: TeeTimeType
  courseId: ID!
  date: String!
  isPrimeTime: Boolean!
  time: String!
}

type TeeTicketPlayerType {
  caddyName: String
  cartType: String!
  handicap: Int
  memberId: String
  name: String!
  position: Int!
  type: String!
}

type TeeTicketType {
  barcode: String
  caddyAssignment: String
  cartAssignment: String
  checkedInAt: DateTime!
  checkedInBy: String!
  clubLogo: String
  clubName: String!
  courseName: String!
  holes: Int!
  notes: String
  players: [TeeTicketPlayerType!]!
  qrCode: String
  teeDate: DateTime!
  teeTime: String!
  ticketNumber: String!
}

type TeeTicketValidationResult {
  message: String
  teeTimeId: ID
  valid: Boolean!
}

type TeeTimeBlockType {
  blockType: BlockType!
  course: GolfCourseType
  courseId: ID!
  createdAt: DateTime!
  endTime: DateTime!
  id: ID!
  isRecurring: Boolean!
  reason: String
  recurringPattern: String
  startTime: DateTime!
  updatedAt: DateTime!
}

type TeeTimeCartsType {
  courseId: ID!
  courseName: String!
  date: DateTime!
  isFullyCheckedIn: Boolean!
  isFullySettled: Boolean!
  slots: [SlotCartType!]!
  teeTime: String!
  teeTimeId: ID!
}

type TeeTimeConnection {
  edges: [TeeTimeTypeEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

input TeeTimePlayerInput {
  caddyId: ID
  caddyRequest: String = "NONE"
  caddyStatus: RentalStatus = NONE

  """Assigned cart ID"""
  cartId: ID
  cartRequest: String = "NONE"
  cartStatus: RentalStatus = NONE
  cartType: CartType = WALKING

  """Dependent UUID (for DEPENDENT player type)"""
  dependentId: ID
  guestEmail: String
  guestName: String
  guestPhone: String

  """Member UUID (for MEMBER player type)"""
  memberId: ID
  playerType: PlayerType!
  position: Int!
  rentalRequest: String = "NONE"
  sharedWithPosition: Int
}

type TeeTimePlayerType {
  caddy: CaddyType
  caddyRequest: String
  caddyStatus: RentalStatus
  cartRequest: String
  cartStatus: RentalStatus
  cartType: CartType!
  checkedInAt: DateTime
  dependent: PlayerDependentType
  guestEmail: String
  guestName: String
  guestPhone: String
  id: ID!
  member: PlayerMemberType
  playerType: PlayerType!
  position: Int!
  rentalRequest: String
  sharedWithPosition: Int
}

"""Tee time booking status"""
enum TeeTimeStatus {
  CANCELLED
  CHECKED_IN
  COMPLETED
  CONFIRMED
  IN_PROGRESS
  NO_SHOW
  PENDING
}

type TeeTimeType {
  bookingGroups: [BookingGroupType!]
  course: GolfCourseType
  createdAt: DateTime!
  holes: Int!
  id: ID!
  notes: String
  players: [TeeTimePlayerType!]!
  startingHole: Int!
  status: TeeTimeStatus!
  teeDate: DateTime!
  teeTime: String!
  teeTimeNumber: String!
  updatedAt: DateTime!
}

type TeeTimeTypeEdge {
  cursor: String!
  node: TeeTimeType!
}

type TicketContentConfigType {
  showCaddyName: Boolean!
  showCartNumber: Boolean!
  showCourse: Boolean!
  showMemberNumbers: Boolean!
  showPlayerNames: Boolean!
  showQRCode: Boolean!
  showRentalItems: Boolean!
  showSpecialRequests: Boolean!
  showStartingHole: Boolean!
  showTeeTime: Boolean!
}

input TicketContentInput {
  showCaddyName: Boolean
  showCartNumber: Boolean
  showCourse: Boolean
  showMemberNumbers: Boolean
  showPlayerNames: Boolean
  showQRCode: Boolean
  showRentalItems: Boolean
  showSpecialRequests: Boolean
  showStartingHole: Boolean
  showTeeTime: Boolean
}

"""When to generate starter ticket"""
enum TicketGenerateOn {
  CHECK_IN
  MANUAL
  SETTLEMENT
}

type TicketValidationResultType {
  message: String
  teeTimeId: ID
  ticketId: ID
  valid: Boolean!
}

input TierDiscountInput {
  discountPercent: Float!
  tierName: String!
}

type TierDiscountType {
  discountPercent: Float!
  tierName: String!
}

enum TileSize {
  LARGE
  MEDIUM
  SMALL
}

type TimePeriodMutationResponse {
  message: String
  success: Boolean!
  timePeriod: GolfTimePeriodType
}

input TimeRuleInput {
  daysOfWeek: [Int!]!
  endTime: String!
  startTime: String!
}

"""Payment transaction status"""
enum TransactionStatus {
  COMPLETED
  PENDING
  REFUNDED
  VOIDED
}

input TransferLineItemInput {
  fromPlayerId: ID!
  lineItemId: ID!
  toPlayerId: ID!
}

type TransferResultType {
  error: String
  isTransferred: Boolean
  lineItemId: ID
  success: Boolean!
  transferredToPlayerId: ID
}

type TransferredItemType {
  amount: Float!
  description: String!
  fromPlayerId: ID!
  fromPlayerName: String!
  lineItemId: ID!
  toPlayerId: ID
  toPlayerName: String
}

"""Twilight calculation mode"""
enum TwilightMode {
  FIXED
  SUNSET
}

input UndoCheckInInput {
  playerId: ID!
  reason: String
}

input UndoTransferInput {
  lineItemId: ID!
}

input UpdateAddressInput {
  addressLine1: String
  addressLine2: String
  country: String
  district: String
  isPrimary: Boolean
  label: String
  postalCode: String
  province: String
  subDistrict: String
  type: AddressType
}

input UpdateApplicationInput {
  email: String
  firstName: String
  lastName: String
  membershipTypeId: ID
  phone: String
  reviewNotes: String
  sponsorId: ID
}

input UpdateBlockInput {
  blockType: BlockType
  endTime: DateTime
  isRecurring: Boolean
  reason: String
  recurringPattern: String
  startTime: DateTime
}

input UpdateButtonRegistryInput {
  registry: JSON!
}

type UpdateButtonRegistryMutationResponse {
  buttonRegistry: POSButtonRegistryGraphQLType
  message: String
  success: Boolean!
}

input UpdateCaddyRateInput {
  amount: Float
  caddyType: String
  taxRate: Float
  taxType: String
}

input UpdateCartRateInput {
  amount: Float
  cartType: String
  taxRate: Float
  taxType: String
}

input UpdateCashDrawerInput {
  id: ID!
  isActive: Boolean
  location: String
  name: String
}

input UpdateClubBillingSettingsInput {
  """Automatically apply late fees when due"""
  autoApplyLateFee: Boolean
  defaultAlignment: CycleAlignment

  """Default billing day (1-28)"""
  defaultBillingDay: Int
  defaultFrequency: BillingFrequency
  defaultTiming: BillingTiming

  """Grace period days after due date (0-60)"""
  gracePeriodDays: Int

  """Days after invoice for payment due (1-60)"""
  invoiceDueDays: Int

  """Days before billing to generate invoices (0-30)"""
  invoiceGenerationLead: Int

  """Fixed late fee amount"""
  lateFeeAmount: Float

  """Late fee percentage (0-100)"""
  lateFeePercentage: Float
  lateFeeType: LateFeeType

  """Maximum late fee cap"""
  maxLateFee: Float

  """Prorate charges for membership changes mid-cycle"""
  prorateChanges: Boolean

  """Prorate charges for new members mid-cycle"""
  prorateNewMembers: Boolean
  prorationMethod: ProrationMethod
}

"""Input for updating communication preferences"""
input UpdateCommunicationPrefsInput {
  emailPromotions: Boolean
  memberId: ID!
  pushNotifications: Boolean
  smsPromotions: Boolean
  unsubscribedCategories: [String!]
}

input UpdateCreditSettingsInput {
  creditAlertThreshold: Float
  creditBlockEnabled: Boolean
  creditLimit: Float
  creditLimitEnabled: Boolean
  creditOverrideAllowed: Boolean
  memberId: ID!
}

input UpdateDependentInput {
  dateOfBirth: DateTime
  email: String
  firstName: String
  isActive: Boolean
  lastName: String
  phone: String
  relationship: String
}

input UpdateDiscountInput {
  approval: DiscountApprovalInput
  code: String
  conditions: DiscountConditionsInput
  isActive: Boolean
  name: String
  scope: DiscountScope
  type: DiscountType
  validity: DiscountValidityInput
  value: Float
}

input UpdateEquipmentCategoryInput {
  attachmentType: EquipmentAttachmentType
  color: String
  defaultRentalRate: Float
  depositAmount: Float
  description: String
  icon: String
  id: ID!
  isActive: Boolean
  name: String
  operationType: OperationType
  requiresDeposit: Boolean
  sortOrder: Int
}

input UpdateEquipmentInput {
  condition: EquipmentCondition
  id: ID!
  lastMaintenanceAt: DateTime
  location: String
  manufacturer: String
  model: String
  name: String
  nextMaintenanceAt: DateTime
  notes: String
  purchaseDate: DateTime
  serialNumber: String
  warrantyExpiry: DateTime
}

input UpdateEquipmentStatusInput {
  id: ID!
  status: EquipmentStatus!
}

input UpdateFacilityInput {
  capacity: Int
  description: String
  features: [String!]
  id: ID!
  isActive: Boolean
  location: String
  name: String
  operatingHours: [DayHoursInput!]
  outletId: ID
  revenueCenterId: ID
  type: ResourceTypeEnum
}

input UpdateGreenFeeRateInput {
  amount: Float
  holes: Int
  playerType: String
  taxRate: Float
  taxType: String
  timeCategory: String
}

input UpdateGroupBookingInput {
  eventDate: DateTime
  groupName: String
  notes: String
  startFormat: StartFormat
  startTime: String
  status: GroupBookingStatus
}

"""Input for updating an interest category"""
input UpdateInterestCategoryInput {
  color: String
  description: String
  icon: String
  isActive: Boolean
  name: String
  sortOrder: Int
}

input UpdateLineItemQuantityInput {
  lineItemId: ID!
  quantity: Int!
}

input UpdateLookupValueInput {
  color: String
  description: String
  icon: String
  id: ID!
  isActive: Boolean
  isDefault: Boolean
  metadata: JSON
  name: String
  sortOrder: Int
}

input UpdateLotteryInput {
  drawTime: DateTime
  lotteryDate: DateTime
  lotteryType: LotteryType
  maxRequestsPerMember: Int
  requestWindowEnd: DateTime
  requestWindowStart: DateTime
  status: LotteryStatus
  timeRangeEnd: String
  timeRangeStart: String
}

input UpdateMemberBillingProfileInput {
  billingAlignment: CycleAlignment
  billingFrequency: BillingFrequency

  """Put billing on hold"""
  billingHold: Boolean

  """Reason for billing hold"""
  billingHoldReason: String

  """Date until billing hold expires"""
  billingHoldUntil: DateTime
  billingTiming: BillingTiming

  """Custom billing day (1-28)"""
  customBillingDay: Int

  """Custom grace period in days"""
  customGracePeriod: Int

  """Exempt from late fees"""
  customLateFeeExempt: Boolean

  """Next scheduled billing date"""
  nextBillingDate: DateTime

  """Internal notes about billing profile"""
  notes: String
  prorationOverride: ProrationMethod
}

input UpdateMemberInput {
  address: String
  dateOfBirth: DateTime
  email: String
  emergencyContact: String
  emergencyPhone: String
  expiryDate: DateTime
  firstName: String
  gender: String
  householdId: ID
  idNumber: String
  isPrimaryMember: Boolean
  lastName: String
  membershipTierId: ID
  membershipTypeId: ID
  nationality: String
  notes: String
  phone: String
  tags: [String!]
}

input UpdateModifierGroupInput {
  isActive: Boolean
  maxSelections: Int
  minSelections: Int
  modifiers: [CreateModifierInput!]
  name: String
  selectionType: ModifierSelectionType
}

input UpdateOutletGridConfigInput {
  categoryStyle: CategoryDisplayStyle
  gridColumns: Int
  gridRows: Int
  quickKeysCount: Int
  quickKeysEnabled: Boolean
  quickKeysPosition: QuickKeysPosition
  showAllCategory: Boolean
  showImages: Boolean
  showPrices: Boolean
  tileSize: TileSize
}

input UpdateOutletProductConfigInput {
  buttonColor: String
  displayName: String
  gridPosition: JSON
  isQuickKey: Boolean
  isVisible: Boolean
  quickKeyPosition: Int
  sortPriority: Int
  visibilityRules: VisibilityRulesInput
}

input UpdatePaymentMethodInput {
  icon: String
  isEnabled: Boolean
  name: String
  opensPOS: Boolean
  requiresRef: Boolean
  type: PaymentMethodTypeEnum
}

input UpdatePlayerRentalStatusInput {
  caddyId: ID
  caddyStatus: RentalStatus
  cartStatus: RentalStatus
}

input UpdateProShopCategoryInput {
  defaultTaxRate: Float
  defaultTaxType: TaxType
  description: String
  isActive: Boolean
  name: String
}

input UpdateProShopProductInput {
  categoryId: ID
  description: String
  isActive: Boolean
  isQuickAdd: Boolean
  name: String
  price: Float
  sku: String
  taxRate: Float
  taxType: TaxType
  useCategoryDefaults: Boolean
  variants: [UpdateProShopVariantInput!]
}

input UpdateProShopVariantInput {
  """Set to true to delete this variant"""
  _delete: Boolean

  """ID for existing variant, omit for new variant"""
  id: ID
  name: String!
  priceAdjustment: Float = 0
  sku: String
}

input UpdateProductCategoryInput {
  color: String
  description: String
  iconName: String
  isActive: Boolean
  name: String
  parentId: ID
  sortOrder: Int
}

input UpdateProductInput {
  basePrice: Float
  bufferMinutes: Int
  categoryId: ID
  costPrice: Float
  description: String
  durationMinutes: Int
  imageUrl: String
  isActive: Boolean
  lowStockThreshold: Int
  modifierGroupIds: [ID!]
  name: String
  productType: ProductType
  requiredCapabilities: [String!]
  sku: String
  sortPriority: Int
  stockQuantity: Int
  taxRate: Float
  thumbnailUrl: String
  trackInventory: Boolean
  variants: [CreateProductVariantInput!]
}

type UpdateQuantityResultType {
  error: String
  lineItem: SlotLineItemType
  success: Boolean!
}

input UpdateRateConfigInput {
  description: String
  effectiveFrom: DateTime
  effectiveTo: DateTime
  isActive: Boolean
  name: String
}

input UpdateRequirementInput {
  allowPartialCredit: Boolean
  defaultShortfallAction: ShortfallAction
  description: String
  effectiveTo: DateTime
  excludedCategories: [String!]
  gracePeriodDays: Int
  includeEvents: Boolean
  includeFoodBeverage: Boolean
  includeGolf: Boolean
  includeRetail: Boolean
  includeSpa: Boolean
  includedCategories: [String!]
  isActive: Boolean
  membershipTypes: [String!]
  minimumAmount: Float
  name: String
  notifyAtPercent: [Int!]
  notifyDaysBeforeEnd: [Int!]
  period: MinimumSpendPeriod
  requirementId: String!
}

input UpdateScheduleConfigInput {
  clubLatitude: Float
  clubLongitude: Float
  defaultBookingWindowDays: Int
  twilightFixedDefault: String
  twilightMinutesBeforeSunset: Int
  twilightMode: TwilightMode
  weekdayBookingMode: BookingMode
  weekdayFirstTee: String
  weekdayLastTee: String
  weekendBookingMode: BookingMode
  weekendFirstTee: String
  weekendLastTee: String
}

input UpdateScheduleInput {
  endDate: DateTime
  firstTeeTime: String
  isActive: Boolean
  lastTeeTime: String
  paceOfPlay: Int
  playFormat: PlayFormat
  seasonName: String
  startDate: DateTime
}

input UpdateSeasonInput {
  endDay: Int
  endMonth: Int
  isRecurring: Boolean
  name: String
  overrideBookingWindow: Int
  overrideFirstTee: String
  overrideLastTee: String
  overrideTimePeriods: Boolean
  overrideTwilightTime: String
  priority: Int
  startDay: Int
  startMonth: Int
  weekdayBookingMode: BookingMode
  weekendBookingMode: BookingMode
}

input UpdateServiceInput {
  basePrice: Float
  bufferMinutes: Int
  category: String
  description: String
  durationMinutes: Int
  id: ID!
  isActive: Boolean
  maxParticipants: Int
  name: String
  requiredCapabilities: [String!]
  requiredFacilityFeatures: [String!]
  revenueCenterId: ID
  tierDiscounts: [TierDiscountInput!]
  variations: [ServiceVariationInput!]
}

input UpdateSettlementTotalsInput {
  refundCount: Int
  settlementId: ID!
  totalCard: Float
  totalCash: Float
  totalDiscounts: Float
  totalGrossSales: Float
  totalMemberAccount: Float
  totalNetSales: Float
  totalOther: Float
  totalRefunds: Float
  totalServiceCharge: Float
  totalTax: Float
  totalVoids: Float
  transactionCount: Int
  voidCount: Int
}

input UpdateSmartSuggestionConfigInput {
  enabled: Boolean
  position: SuggestionPosition
  refreshIntervalMinutes: Int
  salesVelocityWeight: Int
  staffHistoryWeight: Int
  suggestionCount: Int
  timeOfDayWeight: Int
}

input UpdateSpecialDayInput {
  bookingMode: BookingMode
  customFirstTee: String
  customLastTee: String
  customTimePeriods: Boolean
  endDate: String
  isRecurring: Boolean
  name: String
  notes: String
  startDate: String
  type: SpecialDayType
}

input UpdateStaffMemberInput {
  avatarUrl: String
  capabilities: [StaffCapabilityInput!]
  certifications: [StaffCertificationInput!]
  defaultFacilityId: ID
  email: String
  firstName: String
  id: ID!
  isActive: Boolean
  lastName: String
  phone: String
  userId: ID
  workingHours: [DayHoursInput!]
}

input UpdateStoredPaymentInput {
  id: ID!
  isAutoPayEnabled: Boolean
  isDefault: Boolean
}

input UpdateSubAccountInput {
  dailyLimit: Float
  email: String
  monthlyLimit: Float
  name: String
  notifyOnLimitReached: Boolean
  notifyPrimaryOnUse: Boolean
  perTransactionLimit: Float
  permissions: [SubAccountPermission!]
  phone: String
  relationship: String
  subAccountId: String!
  validUntil: DateTime
  weeklyLimit: Float
}

input UpdateTeeTimeInput {
  holes: Int
  notes: String
  players: [TeeTimePlayerInput!]
  status: TeeTimeStatus
}

input UpdateTimePeriodInput {
  applicableDays: ApplicableDays
  endTime: String
  intervalMinutes: Int
  isPrimeTime: Boolean
  name: String
  sortOrder: Int
  startTime: String
}

input UpdateWaitlistEntryInput {
  playerCount: Int
  priority: Int
  requesterEmail: String
  requesterName: String
  requesterPhone: String
  status: GolfWaitlistStatus
  timeRangeEnd: String
  timeRangeStart: String
}

type UpsertTemplateMutationResponse {
  message: String
  success: Boolean!
  template: POSTemplateGraphQLType
}

input ValidateDiscountInput {
  amount: Float!
  code: String
  discountId: ID
  membershipTypeId: ID
  playerType: String
}

input VerifyPinInput {
  pin: String!
  subAccountId: String!
}

input VisibilityRulesInput {
  inventoryRule: String
  memberOnly: Boolean
  roleRules: RoleRulesInput
  timeRules: [TimeRuleInput!]
}

input VoidCreditNoteInput {
  reason: String!
}

input VoidInvoiceInput {
  reason: String!
}

input WaitlistActionInput {
  entryId: ID!
}

type WaitlistConnection {
  edges: [WaitlistEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type WaitlistEdge {
  cursor: String!
  node: WaitlistEntryType!
}

type WaitlistEntryType {
  createdAt: DateTime!
  facilityName: String
  id: ID!
  member: BookingMemberType!
  notes: String
  offerExpiresAt: DateTime
  position: Int!
  requestedDate: DateTime!
  requestedTime: String!
  serviceName: String
  status: WaitlistStatus!
}

type WaitlistMutationResponse {
  message: String
  success: Boolean!
  waitlistEntry: GolfWaitlistType
}

type WaitlistNotificationResult {
  message: String
  notifiedCount: Int!
  notifiedEntries: [GolfWaitlistType!]!
  success: Boolean!
}

type WaitlistResponseType {
  entry: WaitlistEntryType
  error: String
  message: String
  success: Boolean!
}

enum WaitlistStatus {
  ACCEPTED
  DECLINED
  EXPIRED
  OFFER_SENT
  WAITING
}

input WeekViewOccupancyInput {
  courseId: ID!
  endDate: String!

  """Optional end time filter (HH:MM format, e.g., "12:00")"""
  endTime: String
  startDate: String!

  """Optional start time filter (HH:MM format, e.g., "06:00")"""
  startTime: String
}

type WeekViewOccupancyResponse {
  slots: [WeekViewSlotType!]!
}

type WeekViewPlayerType {
  id: ID!
  memberId: String
  name: String!
  type: PlayerType!
}

type WeekViewPositionType {
  player: WeekViewPlayerType
  position: Int!
  status: PositionStatus!
}

type WeekViewSlotType {
  date: String!
  isBlocked: Boolean!
  nine: NineType!
  positions: [WeekViewPositionType!]!
  time: String!
}